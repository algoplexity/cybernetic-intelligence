========== FILE: setup.py ==========

from setuptools import setup
import re

INIT_FILE = "cellpylib/__init__.py"

with open(INIT_FILE) as fid:
    file_contents = fid.read()
    match = re.search(r"^__version__\s?=\s?['\"]([^'\"]*)['\"]", file_contents, re.M)
    if match:
        version = match.group(1)
    else:
        raise RuntimeError("Unable to find version string in %s" % INIT_FILE)

setup(name="cellpylib",
      version=version,
      description="CellPyLib, A library for working with Cellular Automata, for Python.",
      long_description="CellPyLib is a library for working with Cellular Automata, for Python. "
                       "Currently, only 1- and 2-dimensional k-color cellular automata with "
                       "periodic boundary conditions are supported. The size of the "
                       "neighbourhood can be adjusted. ",
      license="Apache License 2.0",
      classifiers=[
            'Development Status :: 5 - Production/Stable',
            'Intended Audience :: Developers',
            'Topic :: Scientific/Engineering :: Artificial Intelligence',
            'License :: OSI Approved :: Apache Software License',
            'Programming Language :: Python :: 3.6',
      ],
      url='http://github.com/lantunes/cellpylib',
      author="Luis M. Antunes",
      author_email="lantunes@gmail.com",
      packages=["cellpylib"],
      keywords=["cellular automata", "complexity", "complex systems", "computation", "non-linear dynamics"],
      python_requires='>3.6',
      install_requires=["numpy >= 1.15.4", "matplotlib >= 3.0.2"])


 

========== FILE: cellpylib/__init__.py ==========

"""
CellPyLib
=========

CellPyLib is a library for working with Cellular Automata.

For complete documentation, see: https://cellpylib.org
"""

__version__ = "2.4.0"

from .ca_functions import BaseRule, AsynchronousRule, ReversibleRule, binary_rule, init_simple, nks_rule, \
    totalistic_rule, plot_multiple, bits_to_int, int_to_bits, init_random, plot, evolve, until_fixed_point, NKSRule, \
    BinaryRule, TotalisticRule, evolve_block

from .rule_tables import random_rule_table, table_walk_through, table_rule

from .entropy import mutual_information, average_cell_entropy, average_mutual_information, shannon_entropy, \
    joint_shannon_entropy

from .ca_functions2d import evolve2d, plot2d, plot2d_slice, plot2d_animate, plot2d_spacetime, init_simple2d, \
    init_random2d, game_of_life_rule, evolve2d_block

from .bien import binary_derivative, cyclic_binary_derivative, ktbien, tbien, bien

from .apen import apen

from .hopfield_net import HopfieldNet

from .ctrbl_rule import CTRBLRule

from .langtons_loop import LangtonsLoop

from .sdsr_loop import SDSRLoop

from .evoloop import Evoloop

from .sandpile import Sandpile


 

========== FILE: cellpylib/apen.py ==========

import numpy as np


def apen(sequence, m=1, r=0):
    """
    Calculates the Approximate Entropy, or ApEn, of the given sequence, as described in:

    .. code-block:: text

      Pincus, S. M.; Gladstone, I. M.; Ehrenkranz, R. A. (1991).
      "A Regularity Statistic For Medical Data Analysis".
      Journal of Clinical Monitoring and Computing. 7 (4): 335-345.

    The implementation here is based on the Python implementation described in:
    https://en.wikipedia.org/wiki/Approximate_entropy

    :param sequence: a string of whole numbers, such as '012301', or an array of whole numbers, such as [0,1,2,3,0,1],
                     or a numpy array of whole numbers

    :param m: the length of compared runs of data

    :param r: a filtering level

    :return: a real number, representing the approximate entropy (ApEn) for the given sequence
    """
    if type(sequence) is str:
        U = np.array([int(x) for x in sequence])
    elif type(sequence) is list:
        U = np.array(sequence)
    elif type(sequence) is np.ndarray:
        U = sequence
    else:
        raise TypeError("unsupported sequence type: %s" % type(sequence))

    N = len(U)

    def maximum_distance(x_i, x_j):
        return max([abs(ua - va) for ua, va in zip(x_i, x_j)])

    def phi(m):
        x = [[U[j] for j in range(i, i + m - 1 + 1)] for i in range(N - m + 1)]
        C = [len([1 for x_j in x if maximum_distance(x_i, x_j) <= r]) / (N - m + 1.0) for x_i in x]
        return (1 / (N - m + 1.0)) * sum(np.log(C))

    return abs(phi(m + 1) - phi(m))


 

========== FILE: cellpylib/bien.py ==========

import math

from .entropy import shannon_entropy


def binary_derivative(string):
    """
    Calculates the binary derivative of the given string, according to:

    .. code-block:: text

        Nathanson, M. B. (1971). Derivatives of binary sequences.
        SIAM Journal on Applied Mathematics, 21(3), 407-412

    The derivative of a binary string is simply the bitwise exclusive OR between a binary digit in the string and
    its successor, if a successor exists. For example, the derivative of the binary string '01010101' is the binary
    string '1111111'.

    :param string: a binary string, such as '110011'

    :return: a binary string representing the binary derivative of the given string
    """
    result = []
    for i, d in enumerate(string):
        if i - 1 == len(string) - 2:
            break
        result.append(int(string[i]) ^ int(string[i + 1]))
    return ''.join([str(x) for x in result])


def bien(string):
    """
    Calculate the BiEntropy of the given binary string, according to:

    .. code-block:: text

        Croll, G. J. (2013). BiEntropy-The Approximate Entropy of a Finite Binary String.
        arXiv preprint arXiv:1305.0954.

    The BiEntropy can be used to compare two binary strings in terms of the relative order and disorder of all the
    digits. It makes use of a weighted average of the Shannon entropies of all but the last binary derivative of the
    given string. This version of BiEntropy is suitable for strings with length <= 32.

    :param string: a binary string, such as '110011'

    :return: a real number representing the BiEntropy of the given string
    """
    tot = 0.0
    n = len(string)
    for k in range(n - 1):
        tot += shannon_entropy(string) * 2**k
        string = binary_derivative(string)
    return (1 / (2**(n - 1) - 1)) * tot


def tbien(string):
    """
    Calculates the logarithmic weighting BiEntropy of the given string, according to:

    .. code-block:: text

        Croll, G. J. (2013). BiEntropy-The Approximate Entropy of a Finite Binary String.
        arXiv preprint arXiv:1305.0954.

    The Logarithmic BiEntropy can be used to compare two binary strings in terms of the relative order and disorder of
    all the digits. It makes use of a logarithmic weighted average of the Shannon entropies of all but the last binary
    derivative of the given string. This version of BiEntropy is suitable for strings with length > 32.

    :param string: a binary string, such as '110011'

    :return: a real number representing the logarithmic weighting BiEntropy of the given string
    """
    tot = 0.0
    tot_log = 0.0
    n = len(string)
    for k in range(n - 1):
        lg = math.log(k + 2, 2.0)
        tot += shannon_entropy(string) * lg
        tot_log += lg
        string = binary_derivative(string)
    return (1 / tot_log) * tot


def cyclic_binary_derivative(string):
    """
    Calculates the cyclic binary derivative, which is the "binary string of length n formed by XORing adjacent pairs of 
    digits including the last and the first." See:

    .. code-block:: text

        Croll, G. J. (2018). The BiEntropy of Some Knots on the Simple Cubic Lattice.
        arXiv preprint arXiv:1802.03772.

    The cyclic derivative of a binary string is simply the bitwise exclusive OR between a binary digit in the string and
    its successor, where the successor of the last digit in the string is the first digit in the string. For example,
    the cyclic derivative of the binary string '01010101' is the binary string '11111111'.

    :param string: a binary string, such as '110011'

    :return: a binary string representing the cyclic binary derivative of the given string
    """
    result = []
    for i, d in enumerate(string):
        s = string[i]
        if i == len(string) - 1:
            next_s = string[0]
        else:
            next_s = string[i + 1]
        result.append(int(s) ^ int(next_s))
    return ''.join([str(x) for x in result])


def ktbien(string):
    """
    Calculates the knot logarithmic weighting BiEntropy of the given string, according to:

    .. code-block:: text

        Croll, G. J. (2018). The BiEntropy of Some Knots on the Simple Cubic Lattice.
        arXiv preprint arXiv:1802.03772.

    The Logarithmic Knot BiEntropy can be used to compare two binary strings in terms of the relative order and disorder
    of all the digits. It makes use of a logarithmic weighted average of the Shannon entropies of all but the last
    cyclic binary derivative of the given string. This version of BiEntropy is suitable for strings with length > 32.

    :param string: a binary string, such as '110011'

    :return: a real number representing the knot logarithmic weighting BiEntropy of the given string
    """
    tot = 0.0
    tot_log = 0.0
    n = len(string)
    for k in range(n - 1):
        lg = math.log(k + 2, 2.0)
        tot += shannon_entropy(string) * lg
        tot_log += lg
        string = cyclic_binary_derivative(string)
    return (1 / tot_log) * tot


 

========== FILE: cellpylib/ca_functions.py ==========

import matplotlib.pyplot as plt
import numpy as np


def plot(ca, title='', *, colormap='Greys', xlabel='', ylabel='time', show=True, **imshow_kwargs):
    """
    Plots the given cellular automaton.

    :param ca: the cellular automaton to plot

    :param title: the title to place on the plot (default is empty)

    :param colormap: the colormap to use (default is 'Greys')

    :param xlabel: the label of the x-axis (default is empty)

    :param ylabel: the label of the y-axis (default 'time')

    :param show: show the plot (default is True)

    :param imshow_kwargs: keyword arguments for the Matplotlib `imshow` function
    """
    cmap = plt.get_cmap(colormap)
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.imshow(ca, interpolation='none', cmap=cmap, **imshow_kwargs)
    if show:
        plt.show()


def plot_multiple(ca_list, titles, *, colormap='Greys', xlabel='', ylabel='time', show=True, **imshow_kwargs):
    """
    Plots multiple cellular automata separately.

    :param ca_list: a list of cellular automata

    :param titles: the titles to give the plots; there must be one title for each CA

    :param colormap: the colormap to use for the plots (default is 'Greys')

    :param xlabel: the label of the x-axis (default is empty)

    :param ylabel: the label of the y-axis (default 'time')

    :param show: show the plot (default is True)

    :param imshow_kwargs: keyword arguments for the Matplotlib `imshow` function
    """
    cmap = plt.get_cmap(colormap)
    for i in range(0, len(ca_list)):
        plt.figure(i)
        plt.title(titles[i])
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.imshow(ca_list[i], interpolation='none', cmap=cmap, **imshow_kwargs)
    if show:
        plt.show()


def evolve_block(cellular_automaton, block_size, timesteps, apply_rule):
    """
    Evolves the given block cellular automaton for the specified time steps. Applies the given function to each block
    during the evolution. A cellular automaton is represented here as an array of arrays, or matrix. This function
    expects an array containing the initial time step (i.e. initial condition, an array) for the cellular automaton.
    The final result is a matrix, where the number of rows equal the number of time steps specified.

    :param cellular_automaton: the cellular automaton starting condition representing the first time step,
                               e.g. [[0,0,0,0,1,0,0,0,0]]

    :param block_size: the number of cells in the block; the total number of cells in the CA must be divisible by the
                       block size

    :param timesteps: the number of time steps in this evolution; this value refers to the total number of time steps
                      in this cellular automaton evolution, which includes the initial condition

    :param apply_rule: a function representing the rule to be applied to each block during the evolution; this function
                       will be given two arguments, in the following order: a tuple containing the activities of the
                       cells in the block, and a scalar representing the timestep in the evolution; this function must
                       return a tuple with the new activities for the block

    :return: a matrix, containing the results of the evolution, where the number of rows equal the number of time steps
             specified
    """
    initial_conditions = cellular_automaton[-1]
    _, cols = cellular_automaton.shape

    if cols % block_size != 0:
        raise Exception("the number of cells in the CA must be divisible by the block size")

    array = np.zeros((timesteps, cols), dtype=cellular_automaton.dtype)
    array[0] = initial_conditions
    cell_indices = list(range(len(initial_conditions)))
    block_indices_odd = [cell_indices[i:i + block_size] for i in range(0, len(cell_indices), block_size)]
    cell_indices = [cell_indices[-1]] + cell_indices[:-1]
    block_indices_even = [cell_indices[i:i + block_size] for i in range(0, len(cell_indices), block_size)]

    for t in range(1, timesteps):
        cells = array[t - 1]
        strides = block_indices_even if t % 2 == 0 else block_indices_odd
        arr = np.zeros(cols, dtype=cellular_automaton.dtype)
        for stride in strides:
            res = apply_rule(tuple(cells[stride]), t)
            for i, r in zip(stride, res):
                arr[i] = r
        array[t] = arr

    return np.concatenate((cellular_automaton, array[1:]), axis=0)


def evolve(cellular_automaton, timesteps, apply_rule, r=1, memoize=False):
    """
    Evolves the given cellular automaton for the specified time steps. Applies the given function to each cell during
    the evolution. A cellular automaton is represented here as an array of arrays, or matrix. This function expects
    an array containing the initial time step (i.e. initial condition, an array) for the cellular automaton. The final
    result is a matrix, where the number of rows equal the number of time steps specified.

    :param cellular_automaton: the cellular automaton starting condition representing the first time step,
                               e.g. [[0,0,0,0,1,0,0,0,0]], or a history of previous states, with the last item in the
                               given array being the starting condition for the evolution,
                               e.g. [[0,0,0,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0]]

    :param timesteps: the number of time steps in this evolution, or a callable that accepts the cellular automaton
                      (in terms of the history of its evolution) and the current timestep number, and is expected to
                      return a boolean indicating whether the evolution should continue; note that if a number is given,
                      this value refers to the total number of time steps in this cellular automaton evolution, which
                      includes the initial condition

    :param apply_rule: a function representing the rule to be applied to each cell during the evolution; this function
                       will be given three arguments, in the following order: the neighbourhood, which is a numpy array
                       of length 2r + 1 representing the neighbourhood of the cell; the cell identity, which is a scalar
                       representing the index of the cell in the cellular automaton array; the time step, which is a 
                       scalar representing the time step in the evolution

    :param r: the neighbourhood radius; the neighbourhood size will be 2r + 1 (default is 1)

    :param memoize: allowed values are True, False, and "recursive"; if True, then the result of applying the rule on a
                    given neighbourhood will be cached, and used on subsequent invocations of the rule; if "recursive",
                    then a recursive memoized algorithm will be used, in which recursively wider neighbourhoods are
                    cached, along with the result of applying the rule on the cells in the widened neighbourhood; the
                    True and "recursive" options can result in a significant improvement to execution speed if the rule
                    is expensive to invoke; the "recursive" option works best when there are strongly repetitive
                    patterns in the CA, and when the state consists of 2^k cells; if False, then no caching will be
                    used; NOTE: this should only be set to True or "recursive" for rules which do not store any state
                    upon invocation, and for rules which do not depend in the cell index or timestep number (default is
                    False)

    :return: a matrix, containing the results of the evolution, where the number of rows equal the number of time steps
             specified
    """
    if callable(timesteps):
        return _evolve_dynamic(cellular_automaton, timesteps, apply_rule, r, memoize)
    else:
        return _evolve_fixed(cellular_automaton, timesteps, apply_rule, r, memoize)


def _evolve_fixed(cellular_automaton, timesteps, apply_rule, r, memoize):
    """
    Evolves the given cellular automaton for the given number of fixed timesteps.

    :param cellular_automaton: the cellular automaton starting condition representing the first time step,
                               e.g. [[0,0,0,0,1,0,0,0,0]], or a history of previous states, with the last item in the
                               given array being the starting condition for the evolution,
                               e.g. [[0,0,0,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0]]

    :param timesteps: the number of time steps in this evolution; this value refers to the total number of time steps in
                      this cellular automaton evolution, which includes the initial condition

    :param apply_rule: a function representing the rule to be applied to each cell during the evolution; this function
                       will be given three arguments, in the following order: the neighbourhood, which is a numpy array
                       of length 2r + 1 representing the neighbourhood of the cell; the cell identity, which is a scalar
                       representing the index of the cell in the cellular automaton array; the time step, which is a
                       scalar representing the time step in the evolution

    :param r: the neighbourhood radius; the neighbourhood size will be 2r + 1

    :param memoize: the memoization flag; one of True, False, or "recursive"

    :return: a matrix, containing the results of the evolution, where the number of rows equal the number of time steps
             specified
    """
    initial_conditions = cellular_automaton[-1]
    _, cols = cellular_automaton.shape
    array = np.zeros((timesteps, cols), dtype=cellular_automaton.dtype)
    array[0] = initial_conditions
    cell_indices = list(range(len(initial_conditions)))

    memo_table = {}

    for t in range(1, timesteps):
        cells = array[t - 1]
        strides = _index_strides(np.arange(len(cells)), 2 * r + 1)
        neighbourhoods = cells[strides]
        if memoize is "recursive":
            next_state = np.zeros(len(cells), dtype=cellular_automaton.dtype)
            _step(cell_indices, cells, next_state, memo_table, apply_rule, r, t)
            array[t] = next_state
        elif memoize is True:
            array[t] = np.array([_get_memoized(n, c, t, apply_rule, memo_table) for c, n in enumerate(neighbourhoods)])
        elif memoize is False:
            array[t] = np.array([apply_rule(n, c, t) for c, n in enumerate(neighbourhoods)])
        else:
            raise Exception("unsupported memoization option: %s" % memoize)

    return np.concatenate((cellular_automaton, array[1:]), axis=0)


def _evolve_dynamic(cellular_automaton, timesteps, apply_rule, r, memoize):
    """
    Evolves the given cellular automaton for a dynamic number of timesteps.

    :param cellular_automaton: the cellular automaton starting condition representing the first time step,
                               e.g. [[0,0,0,0,1,0,0,0,0]], or a history of previous states, with the last item in the
                               given array being the starting condition for the evolution,
                               e.g. [[0,0,0,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0]]

    :param timesteps: a callable that accepts the cellular automaton (in terms of the history of its evolution) and the
                      current timestep number, and is expected to return a boolean indicating whether the evolution
                      should continue

    :param apply_rule: a function representing the rule to be applied to each cell during the evolution; this function
                       will be given three arguments, in the following order: the neighbourhood, which is a numpy array
                       of length 2r + 1 representing the neighbourhood of the cell; the cell identity, which is a scalar
                       representing the index of the cell in the cellular automaton array; the time step, which is a
                       scalar representing the time step in the evolution

    :param r: the neighbourhood radius; the neighbourhood size will be 2r + 1

    :param memoize: the memoization flag; one of True, False, or "recursive"

    :return: a matrix, containing the results of the evolution, where the number of rows equal the number of time steps
             specified
    """
    initial_conditions = cellular_automaton[-1]
    _, cols = cellular_automaton.shape
    array = [initial_conditions]
    cell_indices = list(range(len(initial_conditions)))

    memo_table = {}

    t = 1
    while timesteps(np.array(array), t):
        cells = array[-1]
        strides = _index_strides(np.arange(len(cells)), 2 * r + 1)
        neighbourhoods = cells[strides]
        if memoize is "recursive":
            result = np.zeros(len(cells), dtype=cellular_automaton.dtype)
            _step(cell_indices, cells, result, memo_table, apply_rule, r, t)
        elif memoize is True:
            result = [_get_memoized(n, c, t, apply_rule, memo_table) for c, n in enumerate(neighbourhoods)]
        elif memoize is False:
            result = [apply_rule(n, c, t) for c, n in enumerate(neighbourhoods)]
        else:
            raise Exception("unsupported memoization option: %s" % memoize)
        array.append(np.array(result, dtype=cellular_automaton.dtype))
        t += 1

    return np.concatenate((cellular_automaton, array[1:]), axis=0)


def _step(indices, curr_state, next_state, cache, apply_rule, r, t):
    """
    Perform an update on the given next state using the current state and memoization cache, based on
    an even split of the cell indices.

    :param indices: a list of the cell indices of the cells to update

    :param curr_state: the current state (i.e. the state after the previous timestep)

    :param next_state: the next state (i.e. the result after the current timestep)

    :param cache: a dictionary that maps state neighbourhoods to their activities

    :param apply_rule: the rule to apply during each cell update

    :param r: the neighbourhood radius

    :param t: the current timestep
    """
    mid = len(indices) // 2
    left_indices = indices[:mid]
    right_indices = indices[mid:]
    if len(left_indices) > 0:
        _update_state(left_indices, curr_state, next_state, cache, apply_rule, r, t)
    if len(right_indices) > 0:
        _update_state(right_indices, curr_state, next_state, cache, apply_rule, r, t)


def _update_state(indices, curr_state, next_state, cache, apply_rule, r, t):
    """
    Perform an update on the given next state using the current state and memoization cache.

    :param indices: a list of the cell indices of the cells to update

    :param curr_state: the current state (i.e. the state after the previous timestep)

    :param next_state: the next state (i.e. the result after the current timestep)

    :param cache: a dictionary that maps state neighbourhoods to their activities

    :param apply_rule: the rule to apply during each cell update

    :param r: the neighbourhood radius

    :param t: the current timestep
    """
    # get the state string for the state given by the indices
    start = indices[0]
    end = indices[-1]
    neighbourhood_indices = range(start - r, end + 1 + r)
    neighbourhood = curr_state.take(neighbourhood_indices, mode='wrap')
    state_string = neighbourhood.tobytes()

    if state_string in cache:
        # update next_state with next vals from cache
        next_state[indices] = cache[state_string]
    else:
        if len(indices) > 1:
            _step(indices, curr_state, next_state, cache, apply_rule, r, t)
        else:
            # invoke rule and update next_state for cell
            val = apply_rule(neighbourhood, start, t)
            next_state[start] = val
        # get the result from the next_state for the left_indices and place in cache
        vals_to_cache = next_state[indices]
        cache[state_string] = vals_to_cache


def _get_memoized(n, c, t, apply_rule, memoization_table):
    """
    Checks if the result of `apply_rule` is in the memoization table according to the neighbourhood, `n`,
    and returns the associated value if it is. Otherwise, `apply_rule` is invoked and the result is stored in
    the memoization table, and then returned.

    :param n: a numpy array representing the neighbourhood

    :param c: an int representing the current cell's index

    :param t: an int, representing the current timestep

    :param apply_rule: a function representing the rule to be applied to each cell during the evolution; this function
                       will be given three arguments, in the following order: the neighbourhood, which is a numpy array
                       of length 2r + 1 representing the neighbourhood of the cell; the cell identity, which is a scalar
                       representing the index of the cell in the cellular automaton array; the time step, which is a
                       scalar representing the time step in the evolution

    :param memoization_table: a dictionary mapping a neighbourhood to the rule result for such a neighbourhood

    :return: the result of invoking the given rule with the given n, c, and t arguments
    """
    key = n.tobytes()
    if key in memoization_table:
        return memoization_table[key]
    else:
        result = apply_rule(n, c, t)
        memoization_table[key] = result
        return result


def _index_strides(arr, window_size):
    """
    Returns an array with dimensions len(cells) x window_size, representing the cell indices of the neighbourhood
    of each cell.

    :param arr: an array containing the cell indices; e.g. if there are 5 cells, then the argument
                will be [0, 1, 2, 3, 4]

    :param window_size: the size of the neighbourhood

    :return: an array with dimensions len(cells) x window_size, representing the cell indices of the neighbourhood
             of each cell
    """
    # this function is based on code in http://www.credid.io/cellular-automata-python-2.html
    arr = np.concatenate((arr[-window_size // 2 + 1:], arr, arr[:window_size // 2]))
    shape = arr.shape[:-1] + (arr.shape[-1] - window_size + 1, window_size)
    strides = arr.strides + (arr.strides[-1],)
    return np.lib.stride_tricks.as_strided(arr, shape=shape, strides=strides)


def bits_to_int(bits):
    """
    Converts a binary array representing a binary number into the corresponding int.

    :param bits: a list of 1s and 0s, representing a binary number

    :return: and int representing the corresponding number
    """
    total = 0
    for shift, j in enumerate(bits[::-1]):
        if j:
            total += 1 << shift
    return total


def int_to_bits(num, num_digits):
    """
    Converts the given number, `num`, to the corresponding binary number in the form of a NumPy array of 1s and 0s
    comprised of `num_digits` digits.

    :param num: the number, in base 10, to convert into binary

    :param num_digits: the number of digits the binary number should contain

    :return: a NumPy array of 1s and 0s representing the corresponding binary number
    """
    converted = list(map(int, bin(num)[2:]))
    return np.pad(converted, (num_digits - len(converted), 0), 'constant')


def binary_rule(neighbourhood, rule, scheme=None, powers_of_two=None):
    """
    Converts the given rule number to a binary representation, and uses this to determine the value to return.
    The process is approximately described as:

    .. code-block:: text

        1. convert state to int, so [1,0,1] -> 5, call this state_int

        2. convert rule to binary, so 254 -> [1,1,1,1,1,1,1,0], call this rule_bin_array

        3. new value is rule_bin_array[7 - state_int]
           we subtract 7 from state_int to be consistent with the numbering scheme used in NKS
           in NKS, rule 254 for a 1D binary cellular automaton is described as:

          [1,1,1]  [1,1,0]  [1,0,1]  [1,0,0]  [0,1,1]  [0,1,0]  [0,0,1]  [0,0,0]
             1        1        1        1        1        1        1        0

    If None is provided for the scheme parameter, the neighbourhoods are listed in lexicographic order (the reverse of
    the NKS convention). If 'nks' is provided for the scheme parameter, the NKS convention is used for listing the 
    neighbourhoods.

    :param neighbourhood: a binary array of length 2r + 1

    :param rule: an int or a binary array indicating the cellular automaton rule number

    :param scheme: can be None (default) or 'nks'; if 'nks' is given, the rule numbering scheme used in NKS is used

    :param powers_of_two: a pre-computed array containing the powers of two, e.g. [4,2,1]; can be None (default) or an
                          array of length len(neighbourhood); if an array is given, it will used to speed up the
                          calculation of state_int

    :return: the result, 0 or 1, of applying the given rule on the given state
    """
    if powers_of_two is None:
        state_int = bits_to_int(neighbourhood)
    else:
        assert len(powers_of_two) == len(neighbourhood)
        state_int = neighbourhood.dot(powers_of_two)
    n = 2 ** len(neighbourhood)
    if isinstance(rule, (list, np.ndarray)):
        assert len(rule) == n
        rule_bin_array = rule
    else:
        rule_bin_array = int_to_bits(rule, n)
    if scheme == 'nks':
        return rule_bin_array[(n-1) - state_int]
    return rule_bin_array[state_int]


def nks_rule(neighbourhood, rule):
    """
    A convenience function, that calls binary_rule with scheme = 'nks'.

    :param neighbourhood: a binary array of length 2r + 1

    :param rule: an int indicating the cellular automaton rule number

    :return: the result, 0 or 1, of applying the given rule on the given state
    """
    return binary_rule(neighbourhood, rule, scheme='nks')


def totalistic_rule(neighbourhood, k, rule):
    """
    The totalistic rule as described in NKS. The average color is mapped to a whole number in [0, k - 1].
    The rule number is in base 10, but interpreted in base k. For a 1-dimensional cellular automaton, there are
    3k - 2 possible average colors in the 3-cell neighbourhood. There are n(k - 1) + 1 possible average colors for a 
    k-color cellular automaton with an n-cell neighbourhood.

    :param neighbourhood: a k-color array of any size

    :param k: the number of colors in this cellular automaton, where only 2 <= k <= 36 is supported

    :param rule: the k-color cellular automaton rule number in base 10, interpreted in base k

    :return: the result, a number from 0 to k - 1, of applying the given rule on the given state
    """
    # e.g. np.base_repr(777, base=3) -> '1001210'; the zfill pads the string with zeroes: '1'.zfill(3) -> '001'
    #   Bases greater than 36 not handled in base_repr.
    n = neighbourhood.size
    rule_string = np.base_repr(rule, base=k).zfill(n*(k - 1) + 1)
    if len(rule_string) > n*(k - 1) + 1:
        raise ValueError("rule number out of range")
    neighbourhood_sum = np.sum(neighbourhood)
    # the rightmost element of the rule is for the average color 0, in NKS convention
    return int(rule_string[n*(k - 1) - neighbourhood_sum], k)


def init_simple(size, val=1, dtype=np.int32):
    """
    Returns an array initialized with zeroes, with its center value set to the specified value, or 1 by default.

    :param size: the size of the array to be created

    :param val: the value to be used in the center of the array (1, by default)

    :param dtype: the data type

    :return: a vector with shape (1, size), with its center value initialized to the specified value, or 1 by default
    """
    x = np.zeros(size, dtype=dtype)
    x[len(x)//2] = val
    return np.array([x])


def init_random(size, k=2, n_randomized=None, empty_value=0, dtype=np.int32):
    """
    Returns a randomly initialized array with values consisting of numbers in {0,...,k - 1}, where k = 2 by default.
    If dtype is not an integer type, then values will be uniformly distributed over the half-open interval [0, k - 1).

    :param size: the size of the array to be created

    :param k: the number of states in the cellular automaton (2, by default)

    :param n_randomized: the number of randomized sites in the array; this value must be >= 0 and <= size, if specified;
                         if this value is not specified, all sites in the array will be randomized; the randomized sites
                         will be centered in the array, while all others will have an empty value

    :param empty_value: the value to use for non-randomized sites (0, by default)

    :param dtype: the data type

    :return: a vector with shape (1, size), randomly initialized with numbers in {0,...,k - 1}
    """
    if n_randomized is None:
        n_randomized = size
    if n_randomized > size or n_randomized < 0:
        raise ValueError("the number of randomized sites, if specified, must be >= 0 and <= size")
    pad_left = (size - n_randomized) // 2
    pad_right = (size - n_randomized) - pad_left
    if np.issubdtype(dtype, np.integer):
        rand_nums = np.random.randint(k, size=n_randomized, dtype=dtype)
    else:
        rand_nums = np.random.uniform(0, k - 1, size=n_randomized).astype(dtype)
    return np.array([np.pad(np.array(rand_nums), (pad_left, pad_right), 'constant', constant_values=empty_value)])


def until_fixed_point():
    """
    Returns a callable to be used as the `timesteps` argument to the `evolve` and `evolve2d` functions, that will
    result in the evolution being halted when there have been no changes to the state of the CA in the
    last timestep. That is, if the last state of the CA is the same as the second-to-last state, the
    callable will return `False`, and evolution will be halted.

    :return: a callable to be used as the `timesteps` argument to the `evolve` and `evolve2d` functions
    """
    def _timesteps(ca, t):
        if len(ca) > 1:
            return False if (ca[-2] == ca[-1]).all() else True
        return True
    return _timesteps


class BaseRule:
    """
    A base rule class for custom rules to extend. A rule is a callable that accepts three parameters:
    1, the current cell's neighbourhood; 2, the index identifying the current cell; 3, an int identifying the
    current timestep. The rule returns the activity of the current cell at the next timestep.
    """
    def __call__(self, n, c, t):
        """
        The rule to be implemented by subclasses.

        :param n: the neighbourhood

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the activity of the current cell at the next timestep
        """
        raise NotImplementedError


class NKSRule(BaseRule):
    """
    An Elementary Cellular Automaton rule, indexed according the scheme in NKS.
    """
    def __init__(self, nks_rule_number):
        """
        Creates an instance of an NKS rule.

        :param nks_rule_number: an int indicating the cellular automaton rule number
        """
        self._nks_rule_number = nks_rule_number

    def __call__(self, n, c, t):
        """
        The NKS rule to apply.

        :param n: a binary array of length 2r + 1

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the result, 0 or 1, of applying the given rule on the given state
        """
        return nks_rule(n, self._nks_rule_number)


class BinaryRule(BaseRule):
    """
    A binary representation of the given rule number, which is used to determine the value to return.
    The process is approximately described as:

    .. code-block:: text

        1. convert state to int, so [1,0,1] -> 5, call this state_int

        2. convert rule to binary, so 254 -> [1,1,1,1,1,1,1,0], call this rule_bin_array

        3. new value is rule_bin_array[7 - state_int]
           we subtract 7 from state_int to be consistent with the numbering scheme used in NKS
           in NKS, rule 254 for a 1D binary cellular automaton is described as:

          [1,1,1]  [1,1,0]  [1,0,1]  [1,0,0]  [0,1,1]  [0,1,0]  [0,0,1]  [0,0,0]
             1        1        1        1        1        1        1        0

    If None is provided for the scheme parameter, the neighbourhoods are listed in lexicographic order (the reverse of
    the NKS convention). If 'nks' is provided for the scheme parameter, the NKS convention is used for listing the
    neighbourhoods.
    """
    def __init__(self, rule, scheme=None, powers_of_two=None):
        """
        Creates an instance of a binary rule.

        :param rule: an int or a binary array indicating the cellular automaton rule number

        :param scheme: can be None (default) or 'nks'; if 'nks' is given, the rule numbering scheme used in NKS is used

        :param powers_of_two: a pre-computed array containing the powers of two, e.g. [4,2,1]; can be None (default) or
                              an array of length len(neighbourhood); if an array is given, it will used to speed up the
                              calculation of state_int
        """
        self._rule = rule
        self._scheme = scheme
        self._powers_of_two = powers_of_two

    def __call__(self, n, c, t):
        """
        The binary rule to apply.

        :param n: a binary array of length 2r + 1

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the result, 0 or 1, of applying the given rule on the given state
        """
        return binary_rule(n, self._rule, self._scheme, self._powers_of_two)


class TotalisticRule(BaseRule):
    """
    The totalistic rule as described in NKS. The average color is mapped to a whole number in [0, k - 1].
    The rule number is in base 10, but interpreted in base k. For a 1-dimensional cellular automaton, there are
    3k - 2 possible average colors in the 3-cell neighbourhood. There are n(k - 1) + 1 possible average colors for a
    k-color cellular automaton with an n-cell neighbourhood.
    """
    def __init__(self, k, rule):
        """
        Creates an instance of a totalistic rule.

        :param k: the number of colors in this cellular automaton, where only 2 <= k <= 36 is supported

        :param rule: the k-color cellular automaton rule number in base 10, interpreted in base k
        """
        self._k = k
        self._rule = rule

    def __call__(self, n, c, t):
        """
        The totalistic rule to apply.

        :param n: a k-color array of any size

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the result, a number from 0 to k - 1, of applying the given rule on the given state
        """
        return totalistic_rule(n, self._k, self._rule)


class ReversibleRule(BaseRule):
    """
    An elementary cellular automaton rule explicitly set up to be reversible.
    """
    def __init__(self, init_state, rule_number):
        """
        Creates a reversible elementary cellular automata rule by taking into consideration the previous state of a 
        cell, by taking the XOR of the rule's normal output with the previous state to get the new state.

        :param init_state: a vector representing the initial previous state of the cells, consisting of binary values

        :param rule_number: the elementary cellular automata rule number to be used, in NKS convention
        """
        self._previous_state = init_state
        self._rule_number = rule_number

    def __call__(self, n, c, t):
        """
        The reversible rule to apply.

        :param n: the neighbourhood

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the activity of the current cell at the next timestep
        """
        regular_result = nks_rule(n, self._rule_number)
        new_result = regular_result ^ self._previous_state[c]
        self._previous_state[c] = n[len(n) // 2]
        return new_result


class AsynchronousRule(BaseRule):
    """
    Creates an asynchronous cellular automaton rule with a cyclic update scheme. Also known as a sequential cellular
    automaton rule, in NKS. This rule wraps a given rule, making the given rule asynchronous. This rule works for 
    both 1D and 2D cellular automata.

    This rule requires the specification of an update order (if none is provided, then an order is constructed based
    on the number of cells in the CA). An update order specifies which cell will be updated as the CA evolves. For
    example, the update order [2, 3, 1] states that cell 2 will be updated in the next timestep, followed by cell 3 in
    the subsequent timestep, and then cell 1 in the timestep after that. This update order is adhered to for the
    entire evolution of the CA. Cells that are not being updated do not have the rule applied to them in that timestep.

    An option is provided to randomize the update order at the end of each cycle (i.e. timestep). This is equivalent to
    selecting a cell randomly at each timestep to update, leaving all others unchanged during that timestep.
    """
    def __init__(self, apply_rule, update_order=None, num_cells=None, randomize_each_cycle=False):
        """
        Constructs an asynchronous rule out of a given rule. Either the update_order or num_cells parameter must be
        specified. If no update_order is given, then the num_cells parameter must be specified, and an update order
        list will be constructed and shuffled.

        :param apply_rule: the rule that will be made asynchronous

        :param update_order: a list containing the indices of the cells in the CA, specifying the update order; if the
                             CA is 2D, then instead of indices, cell coordinates are expected (e.g. ((0,1), (2,3),...))

        :param num_cells: an int specifying the total number of cells in the CA if it is 1D, or a 2-tuple representing
                          the height and width of the CA if it is 2D

        :param randomize_each_cycle: whether to shuffle the update order list after each complete cycle
        """
        if update_order is None and num_cells is None:
            raise ValueError("either update_order or num_cells must be specified")
        self._apply_rule = apply_rule
        if update_order is not None:
            self._update_order = update_order
        else:
            self._init_update_order(num_cells)
            self._shuffle_update_order()
        self._curr = 0
        self._num_applied = 0
        self._randomize_each_cycle = randomize_each_cycle

    def _init_update_order(self, num_cells):
        if isinstance(num_cells, tuple):
            self._update_order = [(i, j) for i in range(num_cells[0]) for j in range(num_cells[1])]
        elif isinstance(num_cells, int):
            self._update_order = np.arange(num_cells)
        else:
            raise TypeError("num_cells must be either an int (1D CA) or a 2-tuple (2D CA)")

    def _shuffle_update_order(self):
        np.random.shuffle(self._update_order)

    def __call__(self, n, c, t):
        """
        The asynchronous rule to apply.

        :param n: the neighbourhood

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the activity of the current cell at the next timestep
        """
        if self._in_update_order(c, n):
            self._num_applied += 1
        if not self._should_update(c, n):
            self._check_for_end_of_cycle()
            return self._current_cell_value(n)
        self._check_for_end_of_cycle()
        return self._apply_rule(n, c, t)

    def _in_update_order(self, c, n):
        return c in self._update_order

    def _should_update(self, c, n):
        return c == self._update_order[self._curr]

    def _check_for_end_of_cycle(self):
        if self._num_applied == len(self._update_order):
            self._curr = (self._curr + 1) % len(self._update_order)
            self._num_applied = 0
            if self._randomize_each_cycle:
                self._shuffle_update_order()

    def _current_cell_value(self, n):
        if len(n.shape) == 1:
            return n[len(n)//2]
        elif len(n.shape) == 2:
            return n[n.shape[0]//2][n.shape[1]//2]
        else:
            raise TypeError("unexpected neighbourhood dimensions: %s" % n.shape)


 

========== FILE: cellpylib/ca_functions2d.py ==========

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import matplotlib.collections as mcoll
import numpy as np


def plot2d(ca, timestep=None, title='', *, colormap='Greys', show_grid=False, show_margin=True, scale=0.6,
           show=True, **imshow_kwargs):
    """
    Plots the state of the given 2D cellular automaton at the given timestep. If no timestep is provided, then the last
    timestep is plotted.

    The `show_margin` argument controls whether or not a margin is displayed in the resulting plot. When `show_margin`
    is set to `False`, then the plot takes up the entirety of the window. The `scale` argument is only used when the
    `show_margins` argument is `False`. It controls the resulting scale (i.e. relative size) of the image when there
    are no margins.

    :param ca: the 2D cellular automaton to plot

    :param timestep: the timestep of interest

    :param title: the title to place on the plot

    :param colormap: the color map to use (default is "Greys")

    :param show_grid: whether to display a grid (default is False)

    :param show_margin: whether to display the margin (default is True)

    :param scale: the scale of the figure (default is 0.6)

    :param show: show the plot (default is True)

    :param imshow_kwargs: keyword arguments for the Matplotlib `imshow` function
    """
    cmap = plt.get_cmap(colormap)
    fig, ax = plt.subplots()
    plt.title(title)
    if not show_margin:
        fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)
    if timestep is not None:
        data = ca[timestep]
    else:
        data = ca[-1]

    _add_grid_lines(ca, ax, show_grid)

    im = plt.imshow(data, interpolation='none', cmap=cmap, **imshow_kwargs)
    if not show_margin:
        baseheight, basewidth = im.get_size()
        fig.set_size_inches(basewidth*scale, baseheight*scale, forward=True)
    if show:
        plt.show()


def plot2d_slice(ca, slice=None, title='', *, colormap='Greys', show_grid=False, show_margin=True, scale=0.6,
                 show=True, **imshow_kwargs):
    """
    Plots a slice through the evolved states of a 2D cellular automaton. For example, consider the following `ca`,
    which may represent the evolution of a 3x3 2D cellular automaton over 3 timesteps:

    .. code-block:: text

        [[[ 1,  2,  3],
          [ 4,  5,  6],
          [ 7,  8,  9]],
         [[10, 11, 12],
          [13, 14, 15],
          [16, 17, 18]],
         [[19, 20, 21],
          [22, 23, 24],
          [25, 26, 27]]]

    By default, the following would be plotted:

    .. code-block:: text

        [[ 4,  5,  6],
         [13, 14, 15],
         [22, 23, 24]]

    If `0` is provided as the `slice` argument, then the following would be plotted:

    .. code-block:: text

        [[ 1,  2,  3],
         [10, 11, 12],
         [19, 20, 21]]

    The `show_margin` argument controls whether or not a margin is displayed in the resulting plot. When `show_margin`
    is set to `False`, then the plot takes up the entirety of the window. The `scale` argument is only used when the
    `show_margins` argument is `False`. It controls the resulting scale (i.e. relative size) of the image when there
    are no margins.

    :param ca: the 2D cellular automaton to plot

    :param slice: an int representing the index of the row to plot; by default, the "center" row is used

    :param title: the title to place on the plot

    :param colormap: the color map to use (default is "Greys")

    :param show_grid: whether to display a grid (default is False)

    :param show_margin: whether to display the margin (default is True)

    :param scale: the scale of the figure (default is 0.6)

    :param show: show the plot (default is True)

    :param imshow_kwargs: keyword arguments for the Matplotlib `imshow` function
    """
    cmap = plt.get_cmap(colormap)
    fig, ax = plt.subplots()
    plt.title(title)
    if not show_margin:
        fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)
    if slice is not None:
        data = ca[:, slice]
    else:
        data = ca[:, len(ca[0])//2]

    _add_grid_lines(ca, ax, show_grid)

    im = plt.imshow(data, interpolation='none', cmap=cmap, **imshow_kwargs)
    if not show_margin:
        baseheight, basewidth = im.get_size()
        fig.set_size_inches(basewidth*scale, baseheight*scale, forward=True)
    if show:
        plt.show()


def plot2d_spacetime(ca, alpha=None, title='', show=True):
    """
    Plots the evolution of the given 2D cellular automaton as a 3D space-time plot.

    :param ca: the 2D cellular automaton to plot

    :param alpha: the alpha blending value; a real number between 0 (transparent) and 1 (opaque)

    :param title: the title to place on the plot

    :param show: show the plot (default is True)
    """
    fig = plt.figure(figsize=(10, 7))
    plt.title(title)
    ax = Axes3D(fig)
    ca = ca[::-1]
    xs = np.arange(ca.shape[2])[None, None, :]
    ys = np.arange(ca.shape[1])[None, :, None]
    zs = np.arange(ca.shape[0])[:, None, None]
    xs, ys, zs = np.broadcast_arrays(xs, ys, zs)
    masked_data = np.ma.masked_where(ca == 0, ca)
    ax.scatter(xs.ravel(),
               ys.ravel(),
               zs.ravel(),
               c=masked_data.ravel(), cmap='cool', marker='s', depthshade=False, alpha=alpha, edgecolors='#0F0F0F')
    if show:
        plt.show()


def plot2d_animate(ca, title='', *, colormap='Greys', show_grid=False, show_margin=True, scale=0.6, dpi=80,
                   interval=50, save=False, autoscale=False, show=True, **imshow_kwargs):
    """
    Animate the given 2D cellular automaton.

    The `show_margin` argument controls whether or not a margin is displayed in the resulting plot. When `show_margin`
    is set to `False`, then the plot takes up the entirety of the window. The `scale` argument is only used when the
    `show_margins` argument is `False`. It controls the resulting scale (i.e. relative size) of the image when there
    are no margins.

    The `dpi` argument represents the dots per inch of the animation when it is saved. There will be no visible effect
    of the `dpi` argument if the animation is not saved (i.e. when `save` is `False`).

    :param ca:  the 2D cellular automaton to animate

    :param title: the title to place on the plot (default is "")

    :param colormap: the color map to use (default is "Greys")

    :param show_grid: whether to display a grid (default is False)

    :param show_margin: whether to display the margin (default is True)

    :param scale: the scale of the figure (default is 0.6)

    :param dpi: the dots per inch of the image (default is 80)

    :param interval: the delay between frames in milliseconds (default is 50)

    :param save: whether to save the animation to a local file (default is False)

    :param autoscale: whether to autoscale the images in the animation; this should be set to True if the first
                      frame has a uniform value (e.g. all zeroes) (default is False)

    :param show: show the plot (default is True)

    :param imshow_kwargs: keyword arguments for the Matplotlib `imshow` function

    :return: the animation
    """
    cmap = plt.get_cmap(colormap)
    fig, ax = plt.subplots()
    plt.title(title)
    if not show_margin:
        fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)

    grid = _add_grid_lines(ca, ax, show_grid)

    im = plt.imshow(ca[0], animated=True, cmap=cmap, **imshow_kwargs)
    if not show_margin:
        baseheight, basewidth = im.get_size()
        fig.set_size_inches(basewidth*scale, baseheight*scale, forward=True)

    i = {'index': 0}
    def updatefig(*args):
        i['index'] += 1
        if i['index'] == len(ca):
            i['index'] = 0
        im.set_array(ca[i['index']])
        if autoscale:
            im.autoscale()
        return im, grid
    ani = animation.FuncAnimation(fig, updatefig, interval=interval, blit=True, save_count=len(ca))
    if save:
        ani.save('evolved.gif', dpi=dpi, writer="imagemagick")
    if show:
        plt.show()
    return ani


def _add_grid_lines(ca, ax, show_grid):
    """
    Adds grid lines to the plot.

    :param ca: the 2D cellular automaton to plot

    :param ax: the Matplotlib axis object

    :param show_grid: whether to display the grid lines

    :return: the grid object
    """
    grid_linewidth = 0.0
    if show_grid:
        plt.xticks(np.arange(-.5, len(ca[0][0]), 1), "")
        plt.yticks(np.arange(-.5, len(ca[0]), 1), "")
        plt.tick_params(axis='both', which='both', length=0)
        grid_linewidth = 0.5
    vertical = np.arange(-.5, len(ca[0][0]), 1)
    horizontal = np.arange(-.5, len(ca[0]), 1)
    lines = ([[(x, y) for y in (-.5, horizontal[-1])] for x in vertical] +
             [[(x, y) for x in (-.5, vertical[-1])] for y in horizontal])
    grid = mcoll.LineCollection(lines, linestyles='-', linewidths=grid_linewidth, color='grey')
    ax.add_collection(grid)

    return grid


def evolve2d_block(cellular_automaton, block_size, timesteps, apply_rule):
    """
    Evolves the given block cellular automaton for the specified time steps. Applies the given function to each block
    during the evolution. A cellular automaton is represented here as an array of arrays, or matrix. This function
    expects an array containing the initial time step (i.e. initial condition, an array) for the cellular automaton.
    The final result is a matrix, where the number of rows equal the number of time steps specified.

    :param cellular_automaton: the cellular automaton starting condition representing the first time step

    :param block_size: a 2-tuple representing the number of rows and columns in the block; the total number of cells in
                       the CA must be divisible by the block size

    :param timesteps: the number of time steps in this evolution; this value refers to the total number of time steps
                      in this cellular automaton evolution, which includes the initial condition

    :param apply_rule: a function representing the rule to be applied to each block during the evolution; this function
                       will be given two arguments, in the following order: the block, which is a numpy 2D array with
                       the number of rows and columns specified in the `block_size`, and the time step, which is a
                       scalar representing the time step in the evolution; this function must return a 2D array
                       containing the new values of the block

    :return: a list of matrices, containing the results of the evolution, where the number of rows equal the number
             of time steps specified
    """
    initial_conditions = cellular_automaton[-1]
    _, rows, cols = cellular_automaton.shape
    array = np.zeros((timesteps, rows, cols), dtype=cellular_automaton.dtype)
    array[0] = initial_conditions

    if rows % block_size[0] != 0 or cols % block_size[1] != 0:
        raise Exception("the number of cells in the CA must be divisible by the block size")

    block_indices_odd = []
    for r in list(range(rows))[::block_size[0]]:
        for c in list(range(cols))[::block_size[1]]:
            block_indices_odd.append((
                list(range(r, r+block_size[0])),
                list(range(c, c+block_size[1]))
            ))

    block_indices_even = []
    for row_indices, col_indices in block_indices_odd:
        block_indices_even.append((
            [(i+1) % rows for i in row_indices],
            [(i+1) % cols for i in col_indices]
        ))

    for t in range(1, timesteps):
        cell_layer = array[t - 1]
        strides = block_indices_even if t % 2 == 0 else block_indices_odd
        for row_indices, col_indices in strides:
            n = cell_layer[np.ix_(row_indices, col_indices)]
            array[t][np.ix_(row_indices, col_indices)] = apply_rule(n, t)

    return np.concatenate((cellular_automaton, array[1:]), axis=0)


def evolve2d(cellular_automaton, timesteps, apply_rule, r=1, neighbourhood='Moore', memoize=False):
    """
    Evolves the given cellular automaton for the specified time steps. Applies the given function to each cell during
    the evolution. A cellular automaton is represented here as an array of arrays, or matrix. This function expects
    an array containing the initial time step (i.e. initial condition, an array) for the cellular automaton. The final
    result is a matrix, where the number of rows equal the number of time steps specified.

    :param cellular_automaton: the cellular automaton starting condition representing the first time step, or a history
                               of previous states, with the last item in the given array being the starting condition
                               for the evolution

    :param timesteps: the number of time steps in this evolution, or a callable that accepts the cellular automaton
                      (in terms of the history of its evolution) and the current timestep number, and is expected to
                      return a boolean indicating whether the evolution should continue; note that if a number is given,
                      this value refers to the total number of time steps in this cellular automaton evolution, which
                      includes the initial condition

    :param apply_rule: a function representing the rule to be applied to each cell during the evolution; this function
                       will be given three arguments, in the following order: the neighbourhood, which is a numpy
                       2D array of dimensions 2r+1 x 2r+1, representing the neighbourhood of the cell (if the
                       'von Neumann' neighbourhood is specified, the array will be a masked array); the cell identity,
                       which is a tuple representing the row and column indices of the cell in the cellular automaton
                       matrix, as (row, col); the time step, which is a scalar representing the time step in the
                       evolution

    :param r: the neighbourhood radius; the neighbourhood dimensions will be 2r+1 x 2r+1 (default is 1)

    :param neighbourhood: the neighbourhood type; valid values are 'Moore' or 'von Neumann' (default is 'Moore')

    :param memoize: allowed values are True, False, and "recursive"; if True, then the result of applying the rule on a
                    given neighbourhood will be cached, and used on subsequent invocations of the rule; if "recursive",
                    then a recursive memoized algorithm will be used, in which recursively wider neighbourhoods are
                    cached, along with the result of applying the rule on the cells in the widened neighbourhood; the
                    True and "recursive" options can result in a significant improvement to execution speed if the rule
                    is expensive to invoke; the "recursive" option works best when there are strongly repetitive
                    patterns in the CA, and when the state consists of 2^k x 2^k cells; if False, then no caching will
                    be used; NOTE: this should only be set to True or "recursive" for rules which do not store any state
                    upon invocation, and for rules which do not depend in the cell index or timestep number (default is
                    False)

    :return: a list of matrices, containing the results of the evolution, where the number of rows equal the number
             of time steps specified
    """
    von_neumann_mask = np.zeros((2*r + 1, 2*r + 1), dtype=bool)
    for i in range(len(von_neumann_mask)):
        mask_size = np.absolute(r - i)
        von_neumann_mask[i][:mask_size] = 1
        if mask_size != 0:
            von_neumann_mask[i][-mask_size:] = 1

    _, rows, cols = cellular_automaton.shape
    neighbourhood_indices = _get_neighbourhood_indices(rows, cols, r)

    cell_indices = _get_cell_indices((rows, cols))
    cell_idx_to_neigh_idx = _get_cell_indices_to_neighbourhood_indices(cell_indices, rows, cols, r)

    if callable(timesteps):
        return _evolve2d_dynamic(cellular_automaton, timesteps, apply_rule, neighbourhood, rows, cols,
                                 neighbourhood_indices, von_neumann_mask, memoize, cell_indices, cell_idx_to_neigh_idx)
    else:
        return _evolve2d_fixed(cellular_automaton, timesteps, apply_rule, neighbourhood, rows, cols,
                               neighbourhood_indices, von_neumann_mask, memoize, cell_indices, cell_idx_to_neigh_idx)


def _evolve2d_fixed(cellular_automaton, timesteps, apply_rule, neighbourhood, rows, cols,
                    neighbourhood_indices, von_neumann_mask, memoize, cell_indices, cell_idx_to_neigh_idx):
    """
    Evolves the given cellular automaton for a fixed of timesteps.

    :param cellular_automaton: the cellular automaton starting condition representing the first time step, or a history
                               of previous states, with the last item in the given array being the starting condition
                               for the evolution

    :param timesteps: the number of time steps in this evolution; this value refers to the total number of time steps in
                      this cellular automaton evolution, which includes the initial condition

    :param apply_rule: a function representing the rule to be applied to each cell during the evolution; this function
                       will be given three arguments, in the following order: the neighbourhood, which is a numpy
                       2D array of dimensions 2r+1 x 2r+1, representing the neighbourhood of the cell (if the
                       'von Neumann' neighbourhood is specified, the array will be a masked array); the cell identity,
                       which is a tuple representing the row and column indices of the cell in the cellular automaton
                       matrix, as (row, col); the time step, which is a scalar representing the time step in the
                       evolution

    :param neighbourhood: the neighbourhood type; valid values are 'Moore' or 'von Neumann'

    :param rows: the number of rows in the CA

    :param cols: the number of columns in the CA

    :param neighbourhood_indices: the indices of cells, by neighbourhood

    :param von_neumann_mask: a numpy mask for von Neumann neighbourhoods

    :param memoize: whether to use memoization

    :param cell_indices: a 2D array containing 2-tuples representing the row and column coordinates of each cell

    :param cell_idx_to_neigh_idx: a dictionary mapping groups of cell indices to a group's neighbourhood indices

    :return: a list of matrices, containing the results of the evolution, where the number of rows equal the number
             of time steps specified
    """
    initial_conditions = cellular_automaton[-1]
    array = np.zeros((timesteps, rows, cols), dtype=cellular_automaton.dtype)
    array[0] = initial_conditions

    memo_table = {}
    recursive_cache = _MemoizationCache()

    for t in range(1, timesteps):
        cell_layer = array[t - 1]

        if memoize is "recursive":
            next_state = np.zeros(cell_layer.shape, dtype=cell_layer.dtype)
            _step(cell_indices, cell_idx_to_neigh_idx, cell_layer, next_state, recursive_cache, apply_rule,
                  neighbourhood, von_neumann_mask, t)
            array[t] = next_state
        else:
            for row, cell_row in enumerate(cell_layer):
                for col, cell in enumerate(cell_row):
                    n = _get_neighbourhood(cell_layer, neighbourhood_indices, row, col, neighbourhood, von_neumann_mask)
                    if memoize is True:
                        array[t][row][col] = _get_memoized(n, (row, col), t, apply_rule, memo_table)
                    elif memoize is False:
                        array[t][row][col] = apply_rule(n, (row, col), t)
                    else:
                        raise Exception("unsupported memoization option: %s" % memoize)

    return np.concatenate((cellular_automaton, array[1:]), axis=0)


def _evolve2d_dynamic(cellular_automaton, timesteps, apply_rule, neighbourhood, rows, cols,
                    neighbourhood_indices, von_neumann_mask, memoize, cell_indices, cell_idx_to_neigh_idx):
    """
    Evolves the given cellular automaton for a dynamic number of timesteps.

    :param cellular_automaton: the cellular automaton starting condition representing the first time step, or a history
                               of previous states, with the last item in the given array being the starting condition
                               for the evolution

    :param timesteps: a callable that accepts the cellular automaton (in terms of the history of its evolution) and the
                      current timestep number, and is expected to return a boolean indicating whether the evolution
                      should continue

    :param apply_rule: a function representing the rule to be applied to each cell during the evolution; this function
                       will be given three arguments, in the following order: the neighbourhood, which is a numpy
                       2D array of dimensions 2r+1 x 2r+1, representing the neighbourhood of the cell (if the
                       'von Neumann' neighbourhood is specified, the array will be a masked array); the cell identity,
                       which is a tuple representing the row and column indices of the cell in the cellular automaton
                       matrix, as (row, col); the time step, which is a scalar representing the time step in the
                       evolution

    :param neighbourhood: the neighbourhood type; valid values are 'Moore' or 'von Neumann'

    :param rows: the number of rows in the CA

    :param cols: the number of columns in the CA

    :param neighbourhood_indices: the indices of cells, by neighbourhood

    :param von_neumann_mask: a numpy mask for von Neumann neighbourhoods

    :param memoize: whether to use memoization

    :param cell_indices: a 2D array containing 2-tuples representing the row and column coordinates of each cell

    :param cell_idx_to_neigh_idx: a dictionary mapping groups of cell indices to a group's neighbourhood indices

    :return: a list of matrices, containing the results of the evolution, where the number of rows equal the number
             of time steps specified
    """
    initial_conditions = cellular_automaton[-1]
    array = [initial_conditions]

    memo_table = {}
    recursive_cache = _MemoizationCache()

    t = 1
    while timesteps(np.array(array), t):
        prev_layer = array[-1]
        next_layer = np.zeros((rows, cols), dtype=cellular_automaton.dtype)

        if memoize is "recursive":
            _step(cell_indices, cell_idx_to_neigh_idx, prev_layer, next_layer, recursive_cache, apply_rule,
                  neighbourhood, von_neumann_mask, t)
        else:
            for row, cell_row in enumerate(prev_layer):
                for col, cell in enumerate(cell_row):
                    n = _get_neighbourhood(prev_layer, neighbourhood_indices, row, col, neighbourhood, von_neumann_mask)
                    if memoize is True:
                        next_layer[row][col] = _get_memoized(n, (row, col), t, apply_rule, memo_table)
                    elif memoize is False:
                        next_layer[row][col] = apply_rule(n, (row, col), t)
                    else:
                        raise Exception("unsupported memoization option: %s" % memoize)

        array.append(next_layer)
        t += 1

    return np.concatenate((cellular_automaton, array[1:]), axis=0)


def _get_neighbourhood_indices(rows, cols, r):
    """
    Returns a dictionary mapping the coordinates of a cell in a 2D CA to its neighbourhood indices.

    :param rows: the number of rows in the 2D CA

    :param cols: the number of columns in the 2D CA

    :param r: the radius of the neighbourhood

    :return: a dictionary, where the key is a 2-tuple, (row, col),
             and the value is a 2-tuple, (row_indices, col_indices)
    """
    indices = {}
    for row in range(rows):
        for col in range(cols):
            row_indices = range(row - r, row + r + 1)
            row_indices = [i - rows if i > (rows - 1) else i for i in row_indices]
            col_indices = range(col - r, col + r + 1)
            col_indices = [i - cols if i > (cols - 1) else i for i in col_indices]
            indices[(row, col)] = (row_indices, col_indices)
    return indices


def _get_neighbourhood(cell_layer, neighbourhood_indices, row, col, neighbourhood, von_neumann_mask):
    """
    Returns the cell neighbourhood for the cell given by the row and column index. If the neighbourhood is
    `von Neumann`, then an appropriately masked array is returned.

    :param cell_layer: an array with dimensions 2r+1 x 2r+1

    :param neighbourhood_indices: a 2-tuple containing the row and column indices of the neighbours of the cell given
                                  by the row and column index

    :param row: the row index of the cell

    :param col: the column index of the cell

    :param neighbourhood: the neighbourhood type

    :param von_neumann_mask: a boolean array with dimensions 2r+1 x 2r+1 representing which cells in the neighbourhood
                             should be masked

    :return: a 2r+1 x 2r+1 array representing the cell neighbourhood of the cell given by row and col, if the
             neighbourhood type is `von Neumann`, then the array will be masked
    """
    row_indices, col_indices = neighbourhood_indices[(row, col)]
    n = cell_layer[np.ix_(row_indices, col_indices)]
    if neighbourhood == 'Moore':
        return n
    elif neighbourhood == 'von Neumann':
        return np.ma.masked_array(n, von_neumann_mask)
    else:
        raise ValueError('unknown neighbourhood type: %s' % neighbourhood)


def _get_memoized(n, c, t, apply_rule, memoization_table):
    """
    Checks if the result of `apply_rule` is in the memoization table according to the neighbourhood, `n`,
    and returns the associated value if it is. Otherwise, `apply_rule` is invoked and the result is stored in
    the memoization table, and then returned.

    :param n: a numpy array representing the neighbourhood

    :param c: an int representing the current cell's index

    :param t: an int, representing the current timestep

    :param apply_rule: a function representing the rule to be applied to each cell during the evolution; this function
                       will be given three arguments, in the following order: the neighbourhood, which is a numpy
                       2D array of dimensions 2r+1 x 2r+1, representing the neighbourhood of the cell (if the
                       'von Neumann' neighbourhood is specified, the array will be a masked array); the cell identity,
                       which is a tuple representing the row and column indices of the cell in the cellular automaton
                       matrix, as (row, col); the time step, which is a scalar representing the time step in the
                       evolution

    :param memoization_table: a dictionary mapping a neighbourhood to the rule result for such a neighbourhood

    :return: the result of invoking the given rule with the given n, c, and t arguments
    """
    key = n.tobytes()
    if key in memoization_table:
        return memoization_table[key]
    else:
        result = apply_rule(n, c, t)
        memoization_table[key] = result
        return result


def _get_cell_indices(shape):
    """
    Returns a 2D array containing 2-tuples representing the row and column coordinates of each cell.

    :param shape: a 2-tuple of ints representing the number of rows and columns

    :return: a 2D array containing 2-tuples representing the row and column coordinates of each cell
    """
    indices = []
    rows, cols = shape[0], shape[1]
    for r in range(rows):
        row = []
        for c in range(cols):
            row.append((r, c))
        indices.append(row)
    return np.array(indices, dtype="i, i")


def _get_cell_indices_to_neighbourhood_indices(cell_indices, n_rows, n_cols, r):
    """
    Returns a dictionary which maps groups of cell indices (i.e. 2-tuples of ints representing the row and colummn
    coordinates of cells) to a group's neighbourhood indices. The groups of cells are obtained by recursively dividing
    a 2D array of cell indices into quadrants.

    :param cell_indices: a 2D array containing 2-tuples representing the row and column coordinates of each cell

    :param n_rows: an int representing the number of rows in the 2D CA

    :param n_cols: an int representing the number of columns in the 2D CA

    :param r: an int representing the neighbourhood radius of the 2D CA

    :return: a dictionary mapping groups of cell indices to a group's neighbourhood indices
    """
    cell_indices_to_neighbourhood_indices = {}

    if cell_indices.size == 0:
        return cell_indices_to_neighbourhood_indices

    row_start = cell_indices[0][0][0]
    row_end = cell_indices[-1][0][0]
    col_start = cell_indices[0][0][1]
    col_end = cell_indices[0][-1][1]
    row_indices = range(row_start - r, row_end + r + 1)
    row_indices = [i - n_rows if i > (n_rows - 1) else i for i in row_indices]
    col_indices = range(col_start - r, col_end + r + 1)
    col_indices = [i - n_cols if i > (n_cols - 1) else i for i in col_indices]

    cell_indices_to_neighbourhood_indices[cell_indices.tobytes()] = (row_indices, col_indices)

    if cell_indices.shape[0] > 1 or cell_indices.shape[1] > 1:
        nw_indices, sw_indices, ne_indices, se_indices = _get_sub_matrices(cell_indices)
        cell_indices_to_neighbourhood_indices.update(_get_cell_indices_to_neighbourhood_indices(nw_indices, n_rows, n_cols, r))
        cell_indices_to_neighbourhood_indices.update(_get_cell_indices_to_neighbourhood_indices(ne_indices, n_rows, n_cols, r))
        cell_indices_to_neighbourhood_indices.update(_get_cell_indices_to_neighbourhood_indices(sw_indices, n_rows, n_cols, r))
        cell_indices_to_neighbourhood_indices.update(_get_cell_indices_to_neighbourhood_indices(se_indices, n_rows, n_cols, r))

    return cell_indices_to_neighbourhood_indices


def _get_sub_matrices(arr):
    """
    Takes the given 2D array of 2-tuples representing cell coordinates, and partitions it as evenly as possible into
    4 quadrants, returning the northwest, southwest, northeast, and southeast quadrants as separate 2D arrays, in that
    order.

    :param arr: a 2D array of 2-tuples representing cell coordinates

    :return: the quadrants of the given array as separate 2D arrays, in the order northwest, southwest, northeast,
             and southeast
    """
    indices = []
    indices.extend([x.tolist() for x in np.array_split(np.array_split(arr, 2, axis=1)[0], 2, axis=0)])
    indices.extend([x.tolist() for x in np.array_split(np.array_split(arr, 2, axis=1)[1], 2, axis=0)])
    return np.array(indices[0], dtype="i, i"), np.array(indices[1], dtype="i, i"), \
           np.array(indices[2], dtype="i, i"), np.array(indices[3], dtype="i, i")


def _update_state(cell_indices, cell_idx_to_neigh_idx, curr_state, next_state, cache, apply_rule, neighbourhood_type,
                  von_neumann_mask, t):
    """
    Perform an update on the given next state using the current state and memoization cache.

    :param cell_indices: a 2D array containing 2-tuples representing the row and column coordinates of each cell

    :param cell_idx_to_neigh_idx: a dictionary mapping groups of cell indices to a group's neighbourhood indices

    :param curr_state: the current state (i.e. the state after the previous timestep)

    :param next_state: the next state (i.e. the result after the current timestep)

    :param cache: a mapping from state neighbourhoods to their activities

    :param apply_rule: the rule to apply during each cell update

    :param neighbourhood_type: the neighbourhood type; valid values are 'Moore' or 'von Neumann'

    :param von_neumann_mask: :param von_neumann_mask: a numpy mask for von Neumann neighbourhoods

    :param t: the current timestep
    """
    if cell_indices.size == 0:
        return

    neigh_row_indices, neigh_col_indices = cell_idx_to_neigh_idx[cell_indices.tobytes()]
    state = curr_state[np.ix_(neigh_row_indices, neigh_col_indices)]

    if state in cache:
        # update next_state with next vals from cache
        state_row_indices = neigh_row_indices[1:-1]
        state_col_indices = neigh_col_indices[1:-1]
        next_state[np.ix_(state_row_indices, state_col_indices)] = cache[state]
    else:
        if cell_indices.shape[0] > 1 or cell_indices.shape[1] > 1:
            _step(cell_indices, cell_idx_to_neigh_idx, curr_state, next_state, cache, apply_rule, neighbourhood_type,
                  von_neumann_mask, t)
        else:
            # invoke rule and update next_state for cell
            c = cell_indices[0][0]
            neighbourhood = curr_state[np.ix_(neigh_row_indices, neigh_col_indices)]

            if neighbourhood_type == 'von Neumann':
                neighbourhood = np.ma.masked_array(neighbourhood, von_neumann_mask)
            elif neighbourhood_type != 'Moore':
                raise ValueError('unknown neighbourhood type: %s' % neighbourhood_type)

            val = apply_rule(neighbourhood, c, t)
            next_state[c[0]][c[1]] = val
        # get the result from the next_state for the left_indices and place in cache
        state_row_indices = neigh_row_indices[1:-1]
        state_col_indices = neigh_col_indices[1:-1]
        vals_to_cache = next_state[np.ix_(state_row_indices, state_col_indices)]
        cache[state] = vals_to_cache


def _step(cell_indices, cell_idx_to_neigh_idx, curr_state, next_state, cache, apply_rule, neighbourhood_type,
                  von_neumann_mask, t):
    """
    Perform an update on the given next state using the current state and memoization cache, based on
    an even 4-way split of the cell indices.

    :param cell_indices: a 2D array containing 2-tuples representing the row and column coordinates of each cell

    :param cell_idx_to_neigh_idx: a dictionary mapping groups of cell indices to a group's neighbourhood indices

    :param curr_state: the current state (i.e. the state after the previous timestep)

    :param next_state: the next state (i.e. the result after the current timestep)

    :param cache: a mapping from state neighbourhoods to their activities

    :param apply_rule: the rule to apply during each cell update

    :param neighbourhood_type: the neighbourhood type; valid values are 'Moore' or 'von Neumann'

    :param von_neumann_mask: :param von_neumann_mask: a numpy mask for von Neumann neighbourhoods

    :param t: the current timestep
    """
    nw_indices, sw_indices, ne_indices, se_indices = _get_sub_matrices(cell_indices)
    _update_state(nw_indices, cell_idx_to_neigh_idx, curr_state, next_state, cache, apply_rule, neighbourhood_type,
                  von_neumann_mask, t)
    _update_state(ne_indices, cell_idx_to_neigh_idx, curr_state, next_state, cache, apply_rule, neighbourhood_type,
                  von_neumann_mask, t)
    _update_state(sw_indices, cell_idx_to_neigh_idx, curr_state, next_state, cache, apply_rule, neighbourhood_type,
                  von_neumann_mask, t)
    _update_state(se_indices, cell_idx_to_neigh_idx, curr_state, next_state, cache, apply_rule, neighbourhood_type,
                  von_neumann_mask, t)


def init_simple2d(rows, cols, val=1, dtype=np.int32, coords=None):
    """
    Returns a matrix initialized with zeroes, with its center value set to the specified value, or 1 by default.
    If the `coords` argument is specified, then the specified cell at the given coordinates will have its value
    set to `val`, otherwise the center cell will be set.

    :param rows: the number of rows in the matrix

    :param cols: the number of columns in the matrix

    :param val: the value to be used in the center of the matrix (1, by default)

    :param dtype: the data type (np.int32 by default)

    :param coords: a 2-tuple specifying the row and column of the cell to be initialized (None by default)

    :return: a tensor with shape (1, rows, cols), with the center value initialized to the specified value, or 1 by default
    """
    x = np.zeros((rows, cols), dtype=dtype)
    if coords is not None:
        if not isinstance(coords, (tuple, list)) or len(coords) != 2:
            raise TypeError("coords must be a list or tuple of length 2")
        x[coords[0]][coords[1]] = val
    else:
        x[x.shape[0]//2][x.shape[1]//2] = val
    return np.array([x])


def init_random2d(rows, cols, k=2, dtype=np.int32):
    """
    Returns a randomly initialized matrix with values consisting of numbers in {0,...,k - 1}, where k = 2 by default.
    If dtype is not an integer type, then values will be uniformly distributed over the half-open interval [0, k - 1).

    :param rows: the number of rows in the matrix

    :param cols: the number of columns in the matrix

    :param k: the number of states in the cellular automaton (2, by default)

    :param dtype: the data type

    :return: a tensor with shape (1, rows, cols), randomly initialized with numbers in {0,...,k - 1}
    """
    if np.issubdtype(dtype, np.integer):
        rand_nums = np.random.randint(k, size=(rows, cols), dtype=dtype)
    else:
        rand_nums = np.random.uniform(0, k - 1, size=(rows, cols)).astype(dtype)
    return np.array([rand_nums])


def game_of_life_rule(neighbourhood, c, t):
    """
    Conway's Game of Life rule.

    :param neighbourhood: the current cell's neighbourhood

    :param c: the index of the current cell

    :param t: the current timestep

    :return: the state of the current cell at the next timestep
    """
    center_cell = neighbourhood[1][1]
    total = np.sum(neighbourhood)
    if center_cell == 1:
        if total - 1 < 2:
            return 0  # Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.
        if total - 1 == 2 or total - 1 == 3:
            return 1  # Any live cell with two or three live neighbours lives on to the next generation.
        if total - 1 > 3:
            return 0  # Any live cell with more than three live neighbours dies, as if by overpopulation.
    else:
        if total == 3:
            return 1  # Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
        else:
            return 0


class _MemoizationCache(object):
    """
    A cache that maps 2D numpy arrays to values. The challenge is to inexpensively compute a unique hash for a 2D
    NumPy array, so that it can be used to quickly look up corresponding values. The NumPy array function `tobytes()`
    provides a fast method of producing a unique key for each array, however, it is indifferent to array shape. Thus,
    two arrays with the same contents, but different shapes, would produce the same key. Here, we use an underlying
    dictionary to keep track of collisions (if any) that may occur when two arrays with the same contents but different
    shapes are added to the cache. If a collision occurs, then all values are kept and associated with the originating
    array's shape. At read time, the values for a given array/key are disambiguated using the array's shape.
    """
    def __init__(self):
        self.hashmap = {}

    def put(self, array, val):
        hash = array.tobytes()
        shape = array.shape
        if hash not in self.hashmap:
            self.hashmap[hash] = []
        self.hashmap[hash].append((shape, val))

    def get(self, array):
        hash = array.tobytes()
        shape = array.shape
        collisions = self.hashmap[hash]
        if len(collisions) == 1:
            return collisions[0][1]
        else:
            for collision in collisions:
                collision_shape = collision[0]
                if collision_shape == shape:
                    return collision[1]
            raise Exception("could not find an entry with shape: %s" % shape)

    def __contains__(self, item):
        hash = item.tobytes()
        if hash not in self.hashmap:
            return False
        for collision in self.hashmap[hash]:
            if collision[0] == item.shape:
                return True
        return False

    def __iter__(self):
        for hash in self.hashmap:
            yield hash

    def __len__(self):
        return len(self.hashmap)

    def __setitem__(self, key, value):
        self.put(key, value)

    def __getitem__(self, key):
        return self.get(key)


 

========== FILE: cellpylib/ctrbl_rule.py ==========

from .ca_functions import BaseRule


class CTRBLRule(BaseRule):
    """
    A rule that operates on von Neumann neighbourhoods, taking into account the states of a cell's
    neighbours at the top, right, bottom and left positions. Only supports 2D automata with periodic boundaries and a
    radius of 1.
    """
    def __init__(self, rule_table, add_rotations=False):
        """
        Creates a CTRBLRule.

        :param rule_table: a dictionary with keys being a 5-tuple representing the states of the CTRBL cells, and values
                           being a single value representing the image state (i.e. the state of the Center cell in
                           the next timestep); all combinations of states must exist, otherwise, if the combination of
                           states does not exist in the rule table, an exception will be raised

        :param add_rotations: whether rotations in the rule table are implied, and should be included (default is False)
        """
        self._rule_table = self._init_rule_table(rule_table, add_rotations)

    def __call__(self, n, c, t):
        """
        The CTRBL rule to apply.

        :param n: the neighbourhood

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the activity of the current cell at the next timestep
        """
        current_activity = n[1][1]
        top = n[0][1]
        right = n[1][2]
        bottom = n[2][1]
        left = n[1][0]
        key = (current_activity, top, right, bottom, left)
        if key not in self._rule_table:
            raise ValueError("neighbourhood state (%s, %s, %s, %s, %s) not in rule table" % key)
        return self._rule_table[key]

    @property
    def rule_table(self):
        """
        The rule table for this CTRBL rule.

        :return: the rule table
        """
        return self._rule_table

    @staticmethod
    def _init_rule_table(rule_table, add_rotations):
        new_rule_table = {}
        for rule, image in rule_table.items():
            new_rule_table[rule] = image
            if add_rotations:
                r = list(rule)
                for _ in range(3):
                    r.insert(1, r.pop(4))
                    new_rule_table[tuple(r)] = image
        return new_rule_table


 

========== FILE: cellpylib/entropy.py ==========

import math

import numpy as np


def shannon_entropy(string):
    """
    Calculates the Shannon entropy for the given string.

    :param string: any string, such as '000101001', '12402', or 'aBcd1234ef5g'

    :return: a real number representing the Shannon entropy, in bits
    """
    symbols = dict.fromkeys(list(string))
    symbol_probabilities = [float(string.count(symbol)) / len(string) for symbol in symbols]
    H = -sum([p_symbol * math.log(p_symbol, 2.0) for p_symbol in symbol_probabilities])
    return H + 0  # add 0 as a workaround so we don't end up with -0.0


def average_cell_entropy(cellular_automaton):
    """
    Calculates the average cell entropy in the given cellular automaton, where entropy is the Shannon entropy.
    In the case of a 1D cellular automaton, the state of a cell over time is represented as a string, and its entropy
    is calculated. The same is done for all cells in this cellular automaton, and the average entropy is returned.

    :param cellular_automaton: the cellular automaton to perform this operation on

    :return: a real number representing the average cell Shannon entropy, in bits
    """
    num_cols = cellular_automaton.shape[1]
    entropies = []
    for i in range(0, num_cols):
        cell_states_over_time = ''.join([str(x) for x in cellular_automaton[:, i]])
        entropy = shannon_entropy(cell_states_over_time)
        entropies.append(entropy)
    return np.mean(entropies)


def joint_shannon_entropy(stringX, stringY):
    """
    Calculates the joint Shannon entropy between the given strings, which must be of the same length.

    :param stringX: any string, such as '000101001', '12402', or 'aBcd1234ef5g'

    :param stringY: any string, such as '000101001', '12402', or 'aBcd1234ef5g'

    :return: a real number representing the joint Shannon entropy between the given strings, in bits
    """
    X = np.array(list(stringX))
    Y = np.array(list(stringY))
    joint_symbol_probabilities = []
    for x in set(X):
        for y in set(Y):
            joint_symbol_probabilities.append(np.mean(np.logical_and(X == x, Y == y)))
    return sum([-p * np.log2(p) for p in joint_symbol_probabilities if p != 0])


def mutual_information(stringX, stringY):
    """
    Calculates the mutual information between the given strings, which must be of the same length.

    :param stringX: any string, such as '000101001', '12402', or 'aBcd1234ef5g'

    :param stringY: any string, such as '000101001', '12402', or 'aBcd1234ef5g'

    :return: a real number representing the mutual information between the given strings, in bits
    """
    return shannon_entropy(stringX) + shannon_entropy(stringY) - joint_shannon_entropy(stringX, stringY)


def average_mutual_information(cellular_automaton, temporal_distance=1):
    """
    Calculates the average mutual information between a cell and itself at the next n time steps, given by the 
    specified temporal distance. A temporal distance of 1 means the next time step.

    For example, consider the following string, '00101010110', which represents the state of a cell over 11 time steps.
    The strings which will be used for the computation of the mutual information between a cell and itself at the
    next time step are: '0010101011' and '0101010110', since we pair each time-step value with its next value:

    .. code-block:: text

        " 00101010110"
        "00101010110 "

    :param cellular_automaton: the cellular automaton to perform this operation on

    :param temporal_distance: the size of temporal separation, where the value must be greater than 0 and
                              less than the number of time steps.

    :return: a real number representing the average mutual information between a cell and itself at the next time step,
             in bits
    """
    num_cols = cellular_automaton.shape[1]
    if not (0 < temporal_distance < num_cols):
        raise ValueError("the temporal distance must be greater than 0 and less than the number of time steps")
    mutual_informations = []
    for i in range(0, num_cols):
        cell_states_over_time = ''.join([str(x) for x in cellular_automaton[:, i]])
        mi = mutual_information(cell_states_over_time[:-temporal_distance], cell_states_over_time[temporal_distance:])
        mutual_informations.append(mi)
    return np.mean(mutual_informations)


 

========== FILE: cellpylib/evoloop.py ==========

import numpy as np
from .ctrbl_rule import CTRBLRule


class Evoloop(CTRBLRule):
    """
    An implementation of H. Sayama's Evoloop. For more information, see:

    .. code-block:: text

       Sayama, H. (1998). Constructing evolutionary systems on a simple deterministic cellular automata space.
       PhD, University of Tokyo, Department of Information Science.
    """
    def __init__(self):
        """
        Create an Evoloop.
        """
        super().__init__(rule_table={
            (0, 0, 0, 0, 1): 2,
            (1, 0, 2, 0, 2): 1,
            (1, 1, 2, 7, 2): 7,
            (2, 0, 1, 7, 2): 2,
            (2, 1, 3, 2, 2): 2,
            (4, 0, 1, 2, 5): 0,
            (0, 0, 0, 0, 4): 3,
            (1, 0, 2, 1, 1): 1,
            (1, 1, 2, 7, 3): 5,
            (2, 0, 2, 0, 2): 2,
            (2, 1, 4, 2, 2): 2,
            (4, 0, 1, 6, 2): 0,
            (0, 0, 0, 1, 2): 2,
            (1, 0, 2, 1, 2): 1,
            (1, 1, 3, 2, 2): 1,
            (2, 0, 2, 0, 3): 2,
            (2, 1, 6, 2, 2): 2,
            (4, 0, 2, 1, 2): 0,
            (0, 0, 0, 1, 5): 2,
            (1, 0, 2, 1, 3): 1,
            (1, 1, 3, 3, 2): 1,
            (2, 0, 2, 0, 5): 2,
            (2, 1, 7, 2, 2): 2,
            (4, 0, 2, 1, 5): 0,
            (0, 0, 0, 2, 1): 2,
            (1, 0, 2, 2, 1): 1,
            (1, 1, 5, 4, 2): 4,
            (2, 0, 2, 0, 6): 5,
            (2, 2, 2, 2, 4): 2,
            (4, 0, 2, 2, 2): 1,
            (0, 0, 0, 2, 4): 2,
            (1, 0, 2, 2, 4): 4,
            (1, 1, 5, 7, 2): 7,
            (2, 0, 2, 0, 7): 3,
            (2, 2, 2, 2, 7): 2,
            (4, 0, 2, 3, 2): 1,
            (0, 0, 0, 4, 2): 2,
            (1, 0, 2, 2, 7): 7,
            (1, 1, 6, 2, 4): 4,
            (2, 0, 2, 1, 2): 2,
            (2, 2, 2, 3, 4): 2,
            (4, 0, 2, 6, 2): 6,
            (0, 0, 0, 4, 5): 2,
            (1, 0, 2, 3, 2): 4,
            (1, 1, 6, 2, 7): 7,
            (2, 0, 2, 1, 5): 2,
            (2, 2, 2, 3, 7): 2,
            (4, 0, 3, 1, 2): 0,
            (0, 0, 0, 7, 5): 2,
            (1, 0, 2, 4, 1): 4,
            (1, 2, 2, 2, 4): 4,
            (2, 0, 2, 2, 1): 2,
            (2, 2, 2, 4, 3): 2,
            (4, 0, 3, 2, 2): 1,
            (0, 0, 1, 0, 2): 2,
            (1, 0, 2, 4, 2): 4,
            (1, 2, 2, 2, 7): 7,
            (2, 0, 2, 2, 2): 2,
            (2, 2, 2, 4, 4): 2,
            (5, 0, 0, 0, 2): 5,
            (0, 0, 2, 1, 4): 1,
            (1, 0, 2, 4, 3): 4,
            (1, 2, 2, 4, 3): 4,
            (2, 0, 2, 2, 3): 2,
            (2, 2, 2, 7, 3): 2,
            (5, 0, 0, 1, 2): 5,
            (0, 0, 2, 1, 7): 1,
            (1, 0, 2, 5, 1): 1,
            (1, 2, 2, 7, 3): 7,
            (2, 0, 2, 3, 2): 3,
            (2, 2, 2, 7, 7): 2,
            (5, 0, 0, 2, 1): 5,
            (0, 0, 2, 3, 2): 2,
            (1, 0, 2, 5, 2): 7,
            (1, 2, 3, 2, 4): 4,
            (2, 0, 2, 4, 2): 2,
            (2, 2, 3, 2, 4): 3,
            (5, 0, 0, 2, 3): 2,
            (0, 1, 1, 2, 2): 1,
            (1, 0, 2, 5, 4): 3,
            (1, 2, 3, 2, 7): 7,
            (2, 0, 2, 4, 5): 2,
            (2, 2, 3, 2, 7): 3,
            (5, 0, 0, 2, 4): 5,
            (0, 1, 2, 1, 2): 1,
            (1, 0, 2, 5, 7): 7,
            (1, 2, 4, 2, 6): 6,
            (2, 0, 2, 5, 2): 5,
            (3, 0, 0, 0, 1): 3,
            (5, 0, 0, 2, 7): 5,
            (0, 1, 2, 3, 2): 1,
            (1, 0, 2, 7, 1): 7,
            (1, 2, 4, 3, 3): 3,
            (2, 0, 2, 6, 2): 0,
            (3, 0, 0, 0, 2): 2,
            (5, 0, 0, 4, 2): 5,
            (0, 1, 2, 4, 2): 1,
            (1, 0, 2, 7, 2): 7,
            (1, 2, 6, 2, 7): 6,
            (2, 0, 2, 6, 5): 0,
            (3, 0, 0, 0, 3): 2,
            (5, 0, 0, 7, 2): 5,
            (0, 1, 2, 4, 5): 1,
            (1, 0, 2, 7, 3): 5,
            (2, 0, 0, 0, 1): 2,
            (2, 0, 2, 7, 2): 2,
            (3, 0, 0, 0, 4): 3,
            (5, 0, 2, 0, 2): 2,
            (0, 1, 2, 5, 2): 6,
            (1, 0, 5, 1, 2): 1,
            (2, 0, 0, 0, 2): 2,
            (2, 0, 2, 7, 5): 2,
            (3, 0, 0, 0, 7): 4,
            (5, 0, 2, 0, 5): 2,
            (0, 1, 2, 6, 2): 6,
            (1, 0, 5, 4, 2): 4,
            (2, 0, 0, 0, 4): 2,
            (2, 0, 3, 1, 2): 2,
            (3, 0, 0, 1, 2): 3,
            (5, 0, 2, 1, 2): 5,
            (0, 1, 2, 7, 2): 1,
            (1, 0, 5, 7, 2): 7,
            (2, 0, 0, 0, 5): 2,
            (2, 0, 3, 2, 2): 2,
            (3, 0, 0, 3, 2): 2,
            (5, 0, 2, 1, 5): 2,
            (0, 1, 2, 7, 5): 1,
            (1, 0, 6, 2, 1): 1,
            (2, 0, 0, 0, 6): 0,
            (2, 0, 3, 4, 2): 2,
            (3, 0, 0, 4, 2): 1,
            (5, 0, 2, 4, 2): 5,
            (0, 1, 3, 4, 2): 1,
            (1, 0, 6, 2, 4): 4,
            (2, 0, 0, 0, 7): 1,
            (2, 0, 3, 4, 5): 2,
            (3, 0, 1, 0, 2): 1,
            (5, 0, 2, 7, 2): 5,
            (0, 1, 3, 7, 2): 1,
            (1, 0, 6, 2, 7): 7,
            (2, 0, 0, 1, 2): 2,
            (2, 0, 3, 7, 2): 2,
            (3, 0, 1, 2, 5): 0,
            (5, 0, 3, 1, 2): 0,
            (0, 1, 4, 2, 2): 1,
            (1, 1, 1, 1, 2): 1,
            (2, 0, 0, 1, 5): 2,
            (2, 0, 4, 1, 2): 2,
            (3, 0, 2, 1, 2): 3,
            (6, 0, 2, 0, 2): 2,
            (0, 1, 4, 2, 5): 1,
            (1, 1, 1, 2, 2): 1,
            (2, 0, 0, 2, 1): 2,
            (2, 0, 4, 2, 2): 2,
            (3, 0, 2, 4, 2): 3,
            (6, 0, 2, 1, 2): 2,
            (0, 1, 4, 3, 2): 1,
            (1, 1, 1, 2, 4): 4,
            (2, 0, 0, 2, 2): 2,
            (2, 0, 4, 4, 2): 2,
            (3, 0, 2, 5, 2): 1,
            (6, 0, 2, 2, 2): 0,
            (0, 1, 4, 3, 5): 1,
            (1, 1, 1, 2, 5): 1,
            (2, 0, 0, 2, 3): 2,
            (2, 0, 5, 1, 2): 2,
            (3, 0, 2, 7, 2): 3,
            (6, 0, 2, 4, 2): 2,
            (0, 1, 4, 4, 2): 1,
            (1, 1, 1, 2, 7): 7,
            (2, 0, 0, 2, 4): 2,
            (2, 0, 5, 4, 2): 5,
            (3, 0, 3, 3, 2): 1,
            (6, 0, 2, 7, 2): 2,
            (0, 1, 4, 6, 2): 1,
            (1, 1, 1, 6, 2): 1,
            (2, 0, 0, 2, 6): 0,
            (2, 0, 5, 7, 2): 5,
            (3, 1, 2, 1, 2): 3,
            (6, 1, 2, 2, 2): 0,
            (0, 1, 7, 2, 2): 1,
            (1, 1, 2, 1, 2): 1,
            (2, 0, 0, 2, 7): 2,
            (2, 0, 6, 1, 2): 5,
            (3, 1, 2, 4, 2): 3,
            (6, 2, 2, 2, 4): 0,
            (0, 1, 7, 2, 5): 1,
            (1, 1, 2, 1, 3): 1,
            (2, 0, 0, 3, 2): 4,
            (2, 0, 6, 2, 1): 2,
            (3, 1, 2, 5, 2): 1,
            (6, 2, 2, 2, 7): 0,
            (0, 1, 7, 5, 6): 1,
            (1, 1, 2, 1, 5): 1,
            (2, 0, 0, 4, 2): 3,
            (2, 0, 6, 4, 2): 5,
            (3, 1, 2, 7, 2): 3,
            (7, 0, 1, 0, 2): 0,
            (0, 1, 7, 6, 2): 1,
            (1, 1, 2, 2, 2): 1,
            (2, 0, 0, 4, 5): 2,
            (2, 0, 6, 7, 2): 5,
            (3, 2, 4, 2, 4): 3,
            (7, 0, 1, 1, 2): 0,
            (0, 1, 7, 7, 2): 1,
            (1, 1, 2, 2, 4): 4,
            (2, 0, 0, 5, 4): 5,
            (2, 0, 7, 1, 2): 2,
            (3, 2, 4, 2, 5): 1,
            (7, 0, 1, 2, 2): 0,
            (1, 0, 0, 0, 1): 1,
            (1, 1, 2, 2, 7): 7,
            (2, 0, 0, 5, 7): 5,
            (2, 0, 7, 2, 2): 2,
            (3, 2, 4, 2, 7): 3,
            (7, 0, 1, 2, 5): 0,
            (1, 0, 0, 1, 2): 1,
            (1, 1, 2, 3, 2): 1,
            (2, 0, 0, 6, 2): 0,
            (2, 0, 7, 7, 2): 2,
            (3, 2, 5, 2, 7): 1,
            (7, 0, 1, 6, 2): 0,
            (1, 0, 0, 2, 1): 1,
            (1, 1, 2, 4, 2): 4,
            (2, 0, 0, 7, 2): 2,
            (2, 1, 1, 2, 2): 2,
            (3, 2, 7, 2, 7): 3,
            (7, 0, 2, 1, 2): 0,
            (1, 0, 0, 2, 4): 4,
            (1, 1, 2, 4, 3): 4,
            (2, 0, 0, 7, 5): 2,
            (2, 1, 2, 2, 2): 2,
            (4, 0, 0, 0, 0): 1,
            (7, 0, 2, 1, 5): 0,
            (1, 0, 0, 2, 7): 7,
            (1, 1, 2, 5, 2): 7,
            (2, 0, 1, 0, 2): 2,
            (2, 1, 2, 2, 3): 2,
            (4, 0, 0, 0, 2): 1,
            (7, 0, 2, 2, 2): 1,
            (1, 0, 1, 2, 1): 1,
            (1, 1, 2, 5, 4): 3,
            (2, 0, 1, 1, 2): 2,
            (2, 1, 2, 2, 4): 2,
            (4, 0, 1, 0, 2): 0,
            (7, 0, 2, 3, 2): 0,
            (1, 0, 1, 2, 4): 4,
            (1, 1, 2, 5, 7): 7,
            (2, 0, 1, 2, 2): 2,
            (2, 1, 2, 2, 7): 2,
            (4, 0, 1, 1, 2): 0,
            (7, 0, 2, 6, 2): 6,
            (1, 0, 1, 2, 7): 7,
            (1, 1, 2, 6, 2): 6,
            (2, 0, 1, 4, 2): 2,
            (2, 1, 2, 3, 2): 3,
            (4, 0, 1, 2, 2): 0,
            (7, 0, 3, 1, 2): 0,
        }, add_rotations=True)

    def __call__(self, n, c, t):
        """
        From:
        Sayama, H. (1998). Constructing evolutionary systems on a simple deterministic cellular automata space.
        PhD, University of Tokyo, Department of Information Science.

        :param n: the neighbourhood

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the activity of the current cell at the next timestep
        """
        current_activity = n[1][1]
        top = n[0][1]
        right = n[1][2]
        bottom = n[2][1]
        left = n[1][0]
        key = (current_activity, top, right, bottom, left)

        if key not in self._rule_table:
            trbl = (top, right, bottom, left)
            new_activity = None

            # Let 8->0 with no condition.
            if current_activity == 8:
                new_activity = 0

            # To all the undefined situations in whose four neighbourhood (TRBL) there is at least one site in state 8,
            # apply the following:
            if 8 in trbl:
                # Let 0,1->8 if there is at least one site in state 2,3,...,7 in its four neighbourhood (TRBL),
                # otherwise let 0->0 and 1->1
                if current_activity == 0 or current_activity == 1:
                    if np.any([i in trbl for i in (2, 3, 4, 5, 6, 7)]):
                        new_activity = 8
                    elif current_activity == 0:
                        new_activity = 0
                    elif current_activity == 1:
                        new_activity = 1

                # Let 2,3,5->0.
                if current_activity in (2, 3, 5):
                    new_activity = 0

                # Let 4,6,7->1.
                if current_activity in (4, 6, 7):
                    new_activity = 1

            # Clear up all the undefined situations by letting 0->0 and 1,2,...,7->8.
            if new_activity is None and current_activity == 0:
                new_activity = 0
            if new_activity is None and current_activity in (1, 2, 3, 4, 5, 6, 7):
                new_activity = 8

            return new_activity

        return self._rule_table[key]

    @staticmethod
    def init_species13_loop(dim, row, col):
        """
        Create the initial conditions by specifying the a loop of species 13 and its starting position (as given by the
        coordinates of the first cell of the first row of the loop).

        :param dim: a 2-tuple representing the dimensions (number of rows and columns) of the CA

        :param row: the row number of the loop

        :param col: the column number of the loop

        :return: the initial conditions
        """

        initial_conditions = np.zeros(dim, dtype=np.int32)

        # 1st row
        initial_conditions[row][col] = 2
        initial_conditions[row][col+1] = 2
        initial_conditions[row][col+2] = 2
        initial_conditions[row][col+3] = 2
        initial_conditions[row][col+4] = 2
        initial_conditions[row][col+5] = 2
        initial_conditions[row][col+6] = 2
        initial_conditions[row][col+7] = 2
        initial_conditions[row][col+8] = 2
        initial_conditions[row][col+9] = 2
        initial_conditions[row][col+10] = 2
        initial_conditions[row][col+11] = 2
        initial_conditions[row][col+12] = 2
        initial_conditions[row][col+13] = 2
        initial_conditions[row][col+14] = 2

        # 2nd row
        initial_conditions[row+1][col-1] = 2
        initial_conditions[row+1][col] = 0
        initial_conditions[row+1][col+1] = 1
        initial_conditions[row+1][col+2] = 7
        initial_conditions[row+1][col+3] = 0
        initial_conditions[row+1][col+4] = 1
        initial_conditions[row+1][col+5] = 7
        initial_conditions[row+1][col+6] = 0
        initial_conditions[row+1][col+7] = 1
        initial_conditions[row+1][col+8] = 7
        initial_conditions[row+1][col+9] = 0
        initial_conditions[row+1][col+10] = 1
        initial_conditions[row+1][col+11] = 4
        initial_conditions[row+1][col+12] = 0
        initial_conditions[row+1][col+13] = 1
        initial_conditions[row+1][col+14] = 4
        initial_conditions[row+1][col+15] = 2

        # 3rd row
        initial_conditions[row+2][col-1] = 2
        initial_conditions[row+2][col] = 7
        initial_conditions[row+2][col+1] = 2
        initial_conditions[row+2][col+2] = 2
        initial_conditions[row+2][col+3] = 2
        initial_conditions[row+2][col+4] = 2
        initial_conditions[row+2][col+5] = 2
        initial_conditions[row+2][col+6] = 2
        initial_conditions[row+2][col+7] = 2
        initial_conditions[row+2][col+8] = 2
        initial_conditions[row+2][col+9] = 2
        initial_conditions[row+2][col+10] = 2
        initial_conditions[row+2][col+11] = 2
        initial_conditions[row+2][col+12] = 2
        initial_conditions[row+2][col+13] = 2
        initial_conditions[row+2][col+14] = 0
        initial_conditions[row+2][col+15] = 2

        # 4th row
        initial_conditions[row+3][col-1] = 2
        initial_conditions[row+3][col] = 1
        initial_conditions[row+3][col+1] = 2
        initial_conditions[row+3][col+13] = 2
        initial_conditions[row+3][col+14] = 1
        initial_conditions[row+3][col+15] = 2

        # 5th row
        initial_conditions[row+4][col-1] = 2
        initial_conditions[row+4][col] = 0
        initial_conditions[row+4][col+1] = 2
        initial_conditions[row+4][col+13] = 2
        initial_conditions[row+4][col+14] = 1
        initial_conditions[row+4][col+15] = 2

        # 6th row
        initial_conditions[row+5][col-1] = 2
        initial_conditions[row+5][col] = 7
        initial_conditions[row+5][col+1] = 2
        initial_conditions[row+5][col+13] = 2
        initial_conditions[row+5][col+14] = 1
        initial_conditions[row+5][col+15] = 2

        # 7th row
        initial_conditions[row + 6][col - 1] = 2
        initial_conditions[row + 6][col] = 1
        initial_conditions[row + 6][col + 1] = 2
        initial_conditions[row + 6][col + 13] = 2
        initial_conditions[row + 6][col + 14] = 1
        initial_conditions[row + 6][col + 15] = 2

        # 8th row
        initial_conditions[row + 7][col - 1] = 2
        initial_conditions[row + 7][col] = 0
        initial_conditions[row + 7][col + 1] = 2
        initial_conditions[row + 7][col + 13] = 2
        initial_conditions[row + 7][col + 14] = 1
        initial_conditions[row + 7][col + 15] = 2

        # 9th row
        initial_conditions[row + 8][col - 1] = 2
        initial_conditions[row + 8][col] = 7
        initial_conditions[row + 8][col + 1] = 2
        initial_conditions[row + 8][col + 13] = 2
        initial_conditions[row + 8][col + 14] = 1
        initial_conditions[row + 8][col + 15] = 2

        # 10th row
        initial_conditions[row + 9][col - 1] = 2
        initial_conditions[row + 9][col] = 1
        initial_conditions[row + 9][col + 1] = 2
        initial_conditions[row + 9][col + 13] = 2
        initial_conditions[row + 9][col + 14] = 1
        initial_conditions[row + 9][col + 15] = 2

        # 11th row
        initial_conditions[row + 10][col - 1] = 2
        initial_conditions[row + 10][col] = 0
        initial_conditions[row + 10][col + 1] = 2
        initial_conditions[row + 10][col + 13] = 2
        initial_conditions[row + 10][col + 14] = 1
        initial_conditions[row + 10][col + 15] = 2

        # 12th row
        initial_conditions[row + 11][col - 1] = 2
        initial_conditions[row + 11][col] = 7
        initial_conditions[row + 11][col + 1] = 2
        initial_conditions[row + 11][col + 13] = 2
        initial_conditions[row + 11][col + 14] = 1
        initial_conditions[row + 11][col + 15] = 2

        # 13th row
        initial_conditions[row + 12][col - 1] = 2
        initial_conditions[row + 12][col] = 1
        initial_conditions[row + 12][col + 1] = 2
        initial_conditions[row + 12][col + 13] = 2
        initial_conditions[row + 12][col + 14] = 1
        initial_conditions[row + 12][col + 15] = 2

        # 14th row
        initial_conditions[row + 13][col - 1] = 2
        initial_conditions[row + 13][col] = 0
        initial_conditions[row + 13][col + 1] = 2
        initial_conditions[row + 13][col + 13] = 2
        initial_conditions[row + 13][col + 14] = 1
        initial_conditions[row + 13][col + 15] = 2

        # 15th row
        initial_conditions[row + 14][col - 1] = 2
        initial_conditions[row + 14][col] = 7
        initial_conditions[row + 14][col + 1] = 2
        initial_conditions[row + 14][col + 2] = 2
        initial_conditions[row + 14][col + 3] = 2
        initial_conditions[row + 14][col + 4] = 2
        initial_conditions[row + 14][col + 5] = 2
        initial_conditions[row + 14][col + 6] = 2
        initial_conditions[row + 14][col + 7] = 2
        initial_conditions[row + 14][col + 8] = 2
        initial_conditions[row + 14][col + 9] = 2
        initial_conditions[row + 14][col + 10] = 2
        initial_conditions[row + 14][col + 11] = 2
        initial_conditions[row + 14][col + 12] = 2
        initial_conditions[row + 14][col + 13] = 2
        initial_conditions[row + 14][col + 14] = 1
        initial_conditions[row + 14][col + 15] = 2
        initial_conditions[row + 14][col + 16] = 2
        initial_conditions[row + 14][col + 17] = 2
        initial_conditions[row + 14][col + 18] = 2
        initial_conditions[row + 14][col + 19] = 2
        initial_conditions[row + 14][col + 20] = 2
        initial_conditions[row + 14][col + 21] = 2
        initial_conditions[row + 14][col + 22] = 2
        initial_conditions[row + 14][col + 23] = 2
        initial_conditions[row + 14][col + 24] = 2
        initial_conditions[row + 14][col + 25] = 2
        initial_conditions[row + 14][col + 26] = 2
        initial_conditions[row + 14][col + 27] = 2
        initial_conditions[row + 14][col + 28] = 2

        # 16th row
        initial_conditions[row + 15][col - 1] = 2
        initial_conditions[row + 15][col] = 1
        initial_conditions[row + 15][col + 1] = 0
        initial_conditions[row + 15][col + 2] = 7
        initial_conditions[row + 15][col + 3] = 1
        initial_conditions[row + 15][col + 4] = 0
        initial_conditions[row + 15][col + 5] = 7
        initial_conditions[row + 15][col + 6] = 1
        initial_conditions[row + 15][col + 7] = 0
        initial_conditions[row + 15][col + 8] = 7
        initial_conditions[row + 15][col + 9] = 1
        initial_conditions[row + 15][col + 10] = 0
        initial_conditions[row + 15][col + 11] = 7
        initial_conditions[row + 15][col + 12] = 1
        initial_conditions[row + 15][col + 13] = 0
        initial_conditions[row + 15][col + 14] = 7
        initial_conditions[row + 15][col + 15] = 1
        initial_conditions[row + 15][col + 16] = 1
        initial_conditions[row + 15][col + 17] = 1
        initial_conditions[row + 15][col + 18] = 1
        initial_conditions[row + 15][col + 19] = 1
        initial_conditions[row + 15][col + 20] = 1
        initial_conditions[row + 15][col + 21] = 1
        initial_conditions[row + 15][col + 22] = 1
        initial_conditions[row + 15][col + 23] = 1
        initial_conditions[row + 15][col + 24] = 1
        initial_conditions[row + 15][col + 25] = 1
        initial_conditions[row + 15][col + 26] = 1
        initial_conditions[row + 15][col + 27] = 1
        initial_conditions[row + 15][col + 28] = 1
        initial_conditions[row + 15][col + 29] = 2

        # 17th row
        initial_conditions[row + 16][col] = 2
        initial_conditions[row + 16][col + 1] = 2
        initial_conditions[row + 16][col + 2] = 2
        initial_conditions[row + 16][col + 3] = 2
        initial_conditions[row + 16][col + 4] = 2
        initial_conditions[row + 16][col + 5] = 2
        initial_conditions[row + 16][col + 6] = 2
        initial_conditions[row + 16][col + 7] = 2
        initial_conditions[row + 16][col + 8] = 2
        initial_conditions[row + 16][col + 9] = 2
        initial_conditions[row + 16][col + 10] = 2
        initial_conditions[row + 16][col + 11] = 2
        initial_conditions[row + 16][col + 12] = 2
        initial_conditions[row + 16][col + 13] = 2
        initial_conditions[row + 16][col + 14] = 2
        initial_conditions[row + 16][col + 15] = 2
        initial_conditions[row + 16][col + 16] = 2
        initial_conditions[row + 16][col + 17] = 2
        initial_conditions[row + 16][col + 18] = 2
        initial_conditions[row + 16][col + 19] = 2
        initial_conditions[row + 16][col + 20] = 2
        initial_conditions[row + 16][col + 21] = 2
        initial_conditions[row + 16][col + 22] = 2
        initial_conditions[row + 16][col + 23] = 2
        initial_conditions[row + 16][col + 24] = 2
        initial_conditions[row + 16][col + 25] = 2
        initial_conditions[row + 16][col + 26] = 2
        initial_conditions[row + 16][col + 27] = 2
        initial_conditions[row + 16][col + 28] = 2

        return np.array([initial_conditions])


 

========== FILE: cellpylib/hopfield_net.py ==========

from .ca_functions import *


class HopfieldNet:
    """
    An implementation of the Hopfield network. Due to limitations of this implementation, only an odd number of cells
    is supported.

    For more information on Hopfield networks, see:

    .. code-block:: text

        Hopfield, J. J. (1982). Neural networks and physical systems with emergent collective
        computational abilities. Proceedings of the national academy of sciences, 79(8), 2554-2558.
    """
    def __init__(self, num_cells):
        """
        Create an instance of the Hopfield network.

        :param num_cells: the number of cells in this Hopfield network; only an odd number of cells are supported in
                          this implementation
        """
        self.apply_rule = AsynchronousRule(apply_rule=self._rule, num_cells=num_cells)
        self._r = num_cells // 2

    def train(self, P):
        """
        The training set consists of patterns to be learned by this net. The patterns should be composed of 
        bipolar ({-1,1}), and not binary ({0,1}), values.

        :param P: the set of training patterns
        """
        self._W = np.zeros((len(P[0]), len(P[0])), dtype=np.int32)
        for p in P:
            for i in range(len(p)):
                for j in range(len(p)):
                    if i ==j:
                        self._W[i, j] = 0
                    else:
                        self._W[i, j] += p[i]*p[j]

    def _rule(self, n, c, t):
        left_neighbours = n[0 : len(n)//2]
        right_neighbours = n[len(n)//2 + 1 :]
        V = 0
        for j, left_V in enumerate(left_neighbours):
            V += self._W[c - self._r + j, c] * left_V
        for j, right_V in enumerate(right_neighbours):
            V += self._W[(c + j + 1) % len(n), c] * right_V
        return 1 if V >= 0 else -1

    @property
    def W(self):
        """
        Returns the learned weight matrix.

        :return: the learned weight matrix
        """
        return self._W

    @property
    def r(self):
        """
        The radius of this automaton.

        :return: the radius
        """
        return self._r


 

========== FILE: cellpylib/langtons_loop.py ==========

import numpy as np
from .ctrbl_rule import CTRBLRule


class LangtonsLoop(CTRBLRule):
    """
    An implementation of Langton's Loop, a kind of CTRBL rule. For more information, see:

     .. code-block:: text

        Langton, C. G. (1984). Self-reproduction in Cellular Automata.
        Physica D: Nonlinear Phenomena, 10(1-2), 135-144.

    NOTE: This implementation is meant only for periodic boundary conditions, however, the original Langton's loops
    rules here assume an infinitely sized space. There may be errors due to states missing from the rule table if the
    loops are allowed to overlap. (H. Sayama may have proposed a fix for this in his Ph.D. thesis.)
    """
    def __init__(self):
        """
        Creates a Langton's Loop.
        """
        super().__init__(rule_table={
            (0, 0, 0, 0, 0): 0,
            (0, 0, 0, 0, 1): 2,
            (0, 0, 0, 0, 2): 0,
            (0, 0, 0, 0, 3): 0,
            (0, 0, 0, 0, 5): 0,
            (0, 0, 0, 0, 6): 3,
            (0, 0, 0, 0, 7): 1,
            (0, 0, 0, 1, 1): 2,
            (0, 0, 0, 1, 2): 2,
            (0, 0, 0, 1, 3): 2,
            (0, 0, 0, 2, 1): 2,
            (0, 0, 0, 2, 2): 0,
            (0, 0, 0, 2, 3): 0,
            (0, 0, 0, 2, 6): 2,
            (0, 0, 0, 2, 7): 2,
            (0, 0, 0, 3, 2): 0,
            (0, 0, 0, 5, 2): 5,
            (0, 0, 0, 6, 2): 2,
            (0, 0, 0, 7, 2): 2,
            (0, 0, 1, 0, 2): 2,
            (0, 0, 1, 1, 2): 0,
            (0, 0, 2, 0, 2): 0,
            (0, 0, 2, 0, 3): 0,
            (0, 0, 2, 0, 5): 0,
            (0, 0, 2, 1, 2): 5,
            (0, 0, 2, 2, 2): 0,
            (0, 0, 2, 3, 2): 2,
            (0, 0, 5, 2, 2): 2,
            (0, 1, 2, 3, 2): 1,
            (0, 1, 2, 4, 2): 1,
            (0, 1, 2, 5, 2): 5,
            (0, 1, 2, 6, 2): 1,
            (0, 1, 2, 7, 2): 1,
            (0, 1, 2, 7, 5): 1,
            (0, 1, 4, 2, 2): 1,
            (0, 1, 4, 3, 2): 1,
            (0, 1, 4, 4, 2): 1,
            (0, 1, 4, 7, 2): 1,
            (0, 1, 6, 2, 5): 1,
            (0, 1, 7, 2, 2): 1,
            (0, 1, 7, 2, 5): 5,
            (0, 1, 7, 5, 2): 1,
            (0, 1, 7, 6, 2): 1,
            (0, 1, 7, 7, 2): 1,
            (0, 2, 5, 2, 7): 1,
            (1, 0, 0, 0, 1): 1,
            (1, 0, 0, 0, 6): 1,
            (1, 0, 0, 0, 7): 7,
            (1, 0, 0, 1, 1): 1,
            (1, 0, 0, 1, 2): 1,
            (1, 0, 0, 2, 1): 1,
            (1, 0, 0, 2, 4): 4,
            (1, 0, 0, 2, 7): 7,
            (1, 0, 0, 5, 1): 1,
            (1, 0, 1, 0, 1): 1,
            (1, 0, 1, 1, 1): 1,
            (1, 0, 1, 2, 4): 4,
            (1, 0, 1, 2, 7): 7,
            (1, 0, 2, 0, 2): 6,
            (1, 0, 2, 1, 2): 1,
            (1, 0, 2, 2, 1): 1,
            (1, 0, 2, 2, 4): 4,
            (1, 0, 2, 2, 6): 3,
            (1, 0, 2, 2, 7): 7,
            (1, 0, 2, 3, 2): 7,
            (1, 0, 2, 4, 2): 4,
            (1, 0, 2, 6, 2): 6,
            (1, 0, 2, 6, 4): 4,
            (1, 0, 2, 6, 7): 7,
            (1, 0, 2, 7, 1): 0,
            (1, 0, 2, 7, 2): 7,
            (1, 0, 5, 4, 2): 7,
            (1, 1, 1, 1, 2): 1,
            (1, 1, 1, 2, 2): 1,
            (1, 1, 1, 2, 4): 4,
            (1, 1, 1, 2, 5): 1,
            (1, 1, 1, 2, 6): 1,
            (1, 1, 1, 2, 7): 7,
            (1, 1, 1, 5, 2): 2,
            (1, 1, 2, 1, 2): 1,
            (1, 1, 2, 2, 2): 1,
            (1, 1, 2, 2, 4): 4,
            (1, 1, 2, 2, 5): 1,
            (1, 1, 2, 2, 7): 7,
            (1, 1, 2, 3, 2): 1,
            (1, 1, 2, 4, 2): 4,
            (1, 1, 2, 6, 2): 1,
            (1, 1, 2, 7, 2): 7,
            (1, 1, 3, 2, 2): 1,
            (1, 2, 2, 2, 4): 4,
            (1, 2, 2, 2, 7): 7,
            (1, 2, 2, 4, 3): 4,
            (1, 2, 2, 5, 4): 7,
            (1, 2, 3, 2, 4): 4,
            (1, 2, 3, 2, 7): 7,
            (1, 2, 4, 2, 5): 5,
            (1, 2, 4, 2, 6): 7,
            (1, 2, 5, 2, 7): 5,
            (2, 0, 0, 0, 1): 2,
            (2, 0, 0, 0, 2): 2,
            (2, 0, 0, 0, 4): 2,
            (2, 0, 0, 0, 7): 1,
            (2, 0, 0, 1, 2): 2,
            (2, 0, 0, 1, 5): 2,
            (2, 0, 0, 2, 1): 2,
            (2, 0, 0, 2, 2): 2,
            (2, 0, 0, 2, 3): 2,
            (2, 0, 0, 2, 4): 2,
            (2, 0, 0, 2, 5): 0,
            (2, 0, 0, 2, 6): 2,
            (2, 0, 0, 2, 7): 2,
            (2, 0, 0, 3, 2): 6,
            (2, 0, 0, 4, 2): 3,
            (2, 0, 0, 5, 1): 7,
            (2, 0, 0, 5, 2): 2,
            (2, 0, 0, 5, 7): 5,
            (2, 0, 0, 7, 2): 2,
            (2, 0, 1, 0, 2): 2,
            (2, 0, 1, 1, 2): 2,
            (2, 0, 1, 2, 2): 2,
            (2, 0, 1, 4, 2): 2,
            (2, 0, 1, 7, 2): 2,
            (2, 0, 2, 0, 2): 2,
            (2, 0, 2, 0, 3): 2,
            (2, 0, 2, 0, 5): 2,
            (2, 0, 2, 0, 7): 3,
            (2, 0, 2, 1, 2): 2,
            (2, 0, 2, 1, 5): 2,
            (2, 0, 2, 2, 1): 2,
            (2, 0, 2, 2, 2): 2,
            (2, 0, 2, 2, 7): 2,
            (2, 0, 2, 3, 2): 1,
            (2, 0, 2, 4, 2): 2,
            (2, 0, 2, 4, 5): 2,
            (2, 0, 2, 5, 2): 0,
            (2, 0, 2, 5, 5): 2,
            (2, 0, 2, 6, 2): 2,
            (2, 0, 2, 7, 2): 2,
            (2, 0, 3, 1, 2): 2,
            (2, 0, 3, 2, 1): 6,
            (2, 0, 3, 2, 2): 6,
            (2, 0, 3, 4, 2): 2,
            (2, 0, 4, 2, 2): 2,
            (2, 0, 5, 1, 2): 2,
            (2, 0, 5, 2, 1): 2,
            (2, 0, 5, 2, 2): 2,
            (2, 0, 5, 5, 2): 1,
            (2, 0, 5, 7, 2): 5,
            (2, 0, 6, 2, 2): 2,
            (2, 0, 6, 7, 2): 2,
            (2, 0, 7, 1, 2): 2,
            (2, 0, 7, 2, 2): 2,
            (2, 0, 7, 4, 2): 2,
            (2, 0, 7, 7, 2): 2,
            (2, 1, 1, 2, 2): 2,
            (2, 1, 1, 2, 6): 1,
            (2, 1, 2, 2, 2): 2,
            (2, 1, 2, 2, 4): 2,
            (2, 1, 2, 2, 6): 2,
            (2, 1, 2, 2, 7): 2,
            (2, 1, 4, 2, 2): 2,
            (2, 1, 5, 2, 2): 2,
            (2, 1, 6, 2, 2): 2,
            (2, 1, 7, 2, 2): 2,
            (2, 2, 2, 2, 7): 2,
            (2, 2, 2, 4, 4): 2,
            (2, 2, 2, 4, 6): 2,
            (2, 2, 2, 7, 6): 2,
            (2, 2, 2, 7, 7): 2,
            (3, 0, 0, 0, 1): 3,
            (3, 0, 0, 0, 2): 2,
            (3, 0, 0, 0, 4): 1,
            (3, 0, 0, 0, 7): 6,
            (3, 0, 0, 1, 2): 3,
            (3, 0, 0, 4, 2): 1,
            (3, 0, 0, 6, 2): 2,
            (3, 0, 1, 0, 2): 1,
            (3, 0, 1, 2, 2): 0,
            (3, 0, 2, 5, 1): 1,
            (4, 0, 1, 1, 2): 0,
            (4, 0, 1, 2, 2): 0,
            (4, 0, 1, 2, 5): 0,
            (4, 0, 2, 1, 2): 0,
            (4, 0, 2, 2, 2): 1,
            (4, 0, 2, 3, 2): 6,
            (4, 0, 2, 5, 2): 0,
            (4, 0, 3, 2, 2): 1,
            (5, 0, 0, 0, 2): 2,
            (5, 0, 0, 2, 1): 5,
            (5, 0, 0, 2, 2): 5,
            (5, 0, 0, 2, 3): 2,
            (5, 0, 0, 2, 7): 2,
            (5, 0, 0, 5, 2): 0,
            (5, 0, 2, 0, 2): 2,
            (5, 0, 2, 1, 2): 2,
            (5, 0, 2, 1, 5): 2,
            (5, 0, 2, 2, 2): 0,
            (5, 0, 2, 2, 4): 4,
            (5, 0, 2, 7, 2): 2,
            (5, 1, 2, 1, 2): 2,
            (5, 1, 2, 2, 2): 0,
            (5, 1, 2, 4, 2): 2,
            (5, 1, 2, 7, 2): 2,
            (6, 0, 0, 0, 1): 1,
            (6, 0, 0, 0, 2): 1,
            (6, 0, 2, 1, 2): 0,
            (6, 1, 2, 1, 2): 5,
            (6, 1, 2, 1, 3): 1,
            (6, 1, 2, 2, 2): 5,
            (7, 0, 0, 0, 7): 7,
            (7, 0, 1, 1, 2): 0,
            (7, 0, 1, 2, 2): 0,
            (7, 0, 1, 2, 5): 0,
            (7, 0, 2, 1, 2): 0,
            (7, 0, 2, 2, 2): 1,
            (7, 0, 2, 2, 5): 1,
            (7, 0, 2, 3, 2): 1,
            (7, 0, 2, 5, 2): 5,
            (7, 0, 2, 7, 2): 0
        }, add_rotations=True)

    @staticmethod
    def init_loops(n, dim, row, col):
        """
        Create the initial conditions by specifying the number of loops and their starting positions (as given by the
        coordinates of the first cell of the first row of the loop).

        :param n: the number of loops to create

        :param dim: a 2-tuple representing the dimensions (number of rows and columns) of the CA

        :param row: a list with length n, where the nth item specifies the row number of the nth loop

        :param col: a list with length n, where the nth item specifies the column number of the nth loop

        :return: the initial conditions
        """

        initial_conditions = np.zeros(dim, dtype=np.int32)
        for i in range(n):
            row_i = row[i]
            col_i = col[i]
            # 1st row
            initial_conditions[row_i][col_i] = 2
            initial_conditions[row_i][col_i+1] = 2
            initial_conditions[row_i][col_i+2] = 2
            initial_conditions[row_i][col_i+3] = 2
            initial_conditions[row_i][col_i+4] = 2
            initial_conditions[row_i][col_i+5] = 2
            initial_conditions[row_i][col_i+6] = 2
            initial_conditions[row_i][col_i+7] = 2
            # 2nd row
            initial_conditions[row_i+1][col_i-1] = 2
            initial_conditions[row_i+1][col_i] = 1
            initial_conditions[row_i+1][col_i+1] = 7
            initial_conditions[row_i+1][col_i+2] = 0
            initial_conditions[row_i+1][col_i+3] = 1
            initial_conditions[row_i+1][col_i+4] = 4
            initial_conditions[row_i+1][col_i+5] = 0
            initial_conditions[row_i+1][col_i+6] = 1
            initial_conditions[row_i+1][col_i+7] = 4
            initial_conditions[row_i+1][col_i+8] = 2
            # 3rd row
            initial_conditions[row_i+2][col_i-1] = 2
            initial_conditions[row_i+2][col_i] = 0
            initial_conditions[row_i+2][col_i+1] = 2
            initial_conditions[row_i+2][col_i+2] = 2
            initial_conditions[row_i+2][col_i+3] = 2
            initial_conditions[row_i+2][col_i+4] = 2
            initial_conditions[row_i+2][col_i+5] = 2
            initial_conditions[row_i+2][col_i+6] = 2
            initial_conditions[row_i+2][col_i+7] = 0
            initial_conditions[row_i+2][col_i+8] = 2
            # 4th row
            initial_conditions[row_i+3][col_i-1] = 2
            initial_conditions[row_i+3][col_i] = 7
            initial_conditions[row_i+3][col_i+1] = 2
            initial_conditions[row_i+3][col_i+2] = 0
            initial_conditions[row_i+3][col_i+3] = 0
            initial_conditions[row_i+3][col_i+4] = 0
            initial_conditions[row_i+3][col_i+5] = 0
            initial_conditions[row_i+3][col_i+6] = 2
            initial_conditions[row_i+3][col_i+7] = 1
            initial_conditions[row_i+3][col_i+8] = 2
            # 5th row
            initial_conditions[row_i+4][col_i-1] = 2
            initial_conditions[row_i+4][col_i] = 1
            initial_conditions[row_i+4][col_i+1] = 2
            initial_conditions[row_i+4][col_i+2] = 0
            initial_conditions[row_i+4][col_i+3] = 0
            initial_conditions[row_i+4][col_i+4] = 0
            initial_conditions[row_i+4][col_i+5] = 0
            initial_conditions[row_i+4][col_i+6] = 2
            initial_conditions[row_i+4][col_i+7] = 1
            initial_conditions[row_i+4][col_i+8] = 2
            # 6th row
            initial_conditions[row_i+5][col_i-1] = 2
            initial_conditions[row_i+5][col_i] = 0
            initial_conditions[row_i+5][col_i+1] = 2
            initial_conditions[row_i+5][col_i+2] = 0
            initial_conditions[row_i+5][col_i+3] = 0
            initial_conditions[row_i+5][col_i+4] = 0
            initial_conditions[row_i+5][col_i+5] = 0
            initial_conditions[row_i+5][col_i+6] = 2
            initial_conditions[row_i+5][col_i+7] = 1
            initial_conditions[row_i+5][col_i+8] = 2
            # 7th row
            initial_conditions[row_i+6][col_i-1] = 2
            initial_conditions[row_i+6][col_i] = 7
            initial_conditions[row_i+6][col_i+1] = 2
            initial_conditions[row_i+6][col_i+2] = 0
            initial_conditions[row_i+6][col_i+3] = 0
            initial_conditions[row_i+6][col_i+4] = 0
            initial_conditions[row_i+6][col_i+5] = 0
            initial_conditions[row_i+6][col_i+6] = 2
            initial_conditions[row_i+6][col_i+7] = 1
            initial_conditions[row_i+6][col_i+8] = 2
            # 8th row
            initial_conditions[row_i+7][col_i-1] = 2
            initial_conditions[row_i+7][col_i] = 1
            initial_conditions[row_i+7][col_i+1] = 2
            initial_conditions[row_i+7][col_i+2] = 2
            initial_conditions[row_i+7][col_i+3] = 2
            initial_conditions[row_i+7][col_i+4] = 2
            initial_conditions[row_i+7][col_i+5] = 2
            initial_conditions[row_i+7][col_i+6] = 2
            initial_conditions[row_i+7][col_i+7] = 1
            initial_conditions[row_i+7][col_i+8] = 2
            initial_conditions[row_i+7][col_i+9] = 2
            initial_conditions[row_i+7][col_i+10] = 2
            initial_conditions[row_i+7][col_i+11] = 2
            initial_conditions[row_i+7][col_i+12] = 2
            # 9th row
            initial_conditions[row_i+8][col_i-1] = 2
            initial_conditions[row_i+8][col_i] = 0
            initial_conditions[row_i+8][col_i+1] = 7
            initial_conditions[row_i+8][col_i+2] = 1
            initial_conditions[row_i+8][col_i+3] = 0
            initial_conditions[row_i+8][col_i+4] = 7
            initial_conditions[row_i+8][col_i+5] = 1
            initial_conditions[row_i+8][col_i+6] = 0
            initial_conditions[row_i+8][col_i+7] = 7
            initial_conditions[row_i+8][col_i+8] = 1
            initial_conditions[row_i+8][col_i+9] = 1
            initial_conditions[row_i+8][col_i+10] = 1
            initial_conditions[row_i+8][col_i+11] = 1
            initial_conditions[row_i+8][col_i+12] = 1
            initial_conditions[row_i+8][col_i+13] = 2
            # 10th row
            initial_conditions[row_i+9][col_i] = 2
            initial_conditions[row_i+9][col_i+1] = 2
            initial_conditions[row_i+9][col_i+2] = 2
            initial_conditions[row_i+9][col_i+3] = 2
            initial_conditions[row_i+9][col_i+4] = 2
            initial_conditions[row_i+9][col_i+5] = 2
            initial_conditions[row_i+9][col_i+6] = 2
            initial_conditions[row_i+9][col_i+7] = 2
            initial_conditions[row_i+9][col_i+8] = 2
            initial_conditions[row_i+9][col_i+9] = 2
            initial_conditions[row_i+9][col_i+10] = 2
            initial_conditions[row_i+9][col_i+11] = 2
            initial_conditions[row_i+9][col_i+12] = 2

        return np.array([initial_conditions])


 

========== FILE: cellpylib/rule_tables.py ==========

import random

import numpy as np


def table_rule(neighbourhood, table):
    """
    A rule where the state is converted into a string, and looked up in the given table, to yield the return value.

    :param neighbourhood: a k-color array of length 2r + 1

    :param table: a table (map) of string representations of each neighbourhood state to the associated next
           cell state value; for example, for k = 2 and r = 2, a valid table might be: 
           {'101': 1, '111': 0, '011': 0, '110': 1, '000': 0, '100': 0, '010': 0, '001': 1}

    :return: a number, from 0 to k - 1, associated with the given state as specified in the given table
    """
    state_repr = ''.join(str(x) for x in neighbourhood)
    if not state_repr in table:
        raise ValueError("could not find state '%s' in table" % state_repr)
    return table[state_repr]


def random_rule_table(k, r, lambda_val=None, quiescent_state=None, strong_quiescence=False, isotropic=False):
    """
    Constructs and returns a random rule table using the "random-table" method, as described in:

    .. code-block:: text

        Langton, C. G. (1990). Computation at the edge of chaos: phase transitions
        and emergent computation.
        Physica D: Nonlinear Phenomena, 42(1-3), 12-37.

    :param k: the number of cell states

    :param r: the radius of the cellular automaton neighbourhood

    :param lambda_val: a real number in (0., 1.), representing the value of lambda; if None, a default value of
                       1.0 - 1/k will be used, where all states will be represented equally in the rule table

    :param quiescent_state: the state, a number in {0,...,k - 1}, to use as the quiescent state

    :param strong_quiescence: if True, all neighbourhood states uniform in cell state i will map to cell state i

    :param isotropic: if True, all planar rotations of a neighbourhood state will map to the same cell state

    :return: a tuple containing: a table describing a rule, constructed using the "random-table" table method as
             described by C. G. Langton, the actual lambda value, and the quiescent state used
    """
    states = []
    n = 2*r + 1
    for i in range(0, k**n):
        states.append(np.base_repr(i, k).zfill(n))
    table = {}
    if lambda_val is None:
        lambda_val = 1. - (1. / k)
    if quiescent_state is None:
        quiescent_state = np.random.randint(k, dtype=np.int32)
    if not (0 <= quiescent_state <= k - 1):
        raise ValueError("quiescent state must be a number in {0,...,k - 1}")
    other_states = [x for x in range(0, k) if x != quiescent_state]
    quiescent_state_count = 0
    for state in states:
        if strong_quiescence and len(set(state)) == 1:
            # if the cell states in neighbourhood are all the same, e.g. '111'
            cell_state = int(state[0], k)
            if cell_state == quiescent_state: quiescent_state_count += 1
        else:
            state_reversed = state[::-1]
            if isotropic and state_reversed in table:
                cell_state = table[state_reversed]
                if cell_state == quiescent_state: quiescent_state_count += 1
            else:
                if random.random() < (1. - lambda_val):
                    cell_state = quiescent_state
                    quiescent_state_count += 1
                else:
                    cell_state = random.choice(other_states)
        table[state] = cell_state
    actual_lambda_val = (k**n - quiescent_state_count) / k**n
    return table, actual_lambda_val, quiescent_state


def table_walk_through(rule_table, lambda_val, k, r, quiescent_state, strong_quiescence=False, isotropic=False):
    """
    Perturbs the given rule table using the "table-walk-through" approach described in:

    .. code-block:: text

        Langton, C. G. (1990). Computation at the edge of chaos: phase transitions
        and emergent computation.
        Physica D: Nonlinear Phenomena, 42(1-3), 12-37.

    The table's actual lambda value will be increased or decreased, incrementally and stochastically, until it reaches
    the given lambda value.

    :param rule_table: a table (map) of string representations of each neighbourhood state to the associated next 
                       cell state value; for example, for k = 2 and r = 2, a valid table might be: 
                       {'101': 1, '111': 0, '011': 0, '110': 1, '000': 0, '100': 0, '010': 0, '001': 1}

    :param lambda_val: a real number in (0., 1.), representing the value of lambda

    :param k: the number of cell states

    :param r: the radius of the cellular automaton neighbourhood

    :param quiescent_state: the state, a number in {0,...,k - 1}, to use as the quiescent state

    :param strong_quiescence: if True, all neighbourhood states uniform in cell state i will map to cell state i

    :param isotropic: if True, all planar rotations of a neighbourhood state will map to the same cell state

    :return: a tuple containing: a table describing a rule, constructed using the "table-walk-through" method as
             described by C. G. Langton, the actual lambda value
    """
    def actual_lambda():
        n = 2*r + 1
        transitions_to_quiescent_state = list(rule_table.values()).count(quiescent_state)
        return (k**n - transitions_to_quiescent_state) / k**n
    actual_lambda_val = actual_lambda()
    if actual_lambda_val == lambda_val:
        return rule_table, actual_lambda_val
    if actual_lambda_val > lambda_val:
        # reduce lambda
        attempts = 0
        while actual_lambda() > lambda_val and attempts < len(rule_table):
            attempts += 1
            states_to_others = [k for k in rule_table.keys() if rule_table[k] != quiescent_state]
            if strong_quiescence:
                # remove states that are all the same (i.e. '111'); presumably the strong quiescence condition is already
                #  enforced in the incoming rule table, and so these states shouldn't be changed
                states_to_others = [s for s in states_to_others if len(set(s)) != 1]
            if len(states_to_others) == 0:
                break
            state_to_perturb = random.choice(states_to_others)
            rule_table[state_to_perturb] = quiescent_state
            if isotropic:
                state_to_perturb_reversed = state_to_perturb[::-1]
                rule_table[state_to_perturb_reversed] = rule_table[state_to_perturb]
    elif actual_lambda_val < lambda_val:
        # increase lambda
        attempts = 0
        while actual_lambda() < lambda_val and attempts < len(rule_table):
            attempts += 1
            states_to_quiescent = [k for k in rule_table.keys() if rule_table[k] == quiescent_state]
            if strong_quiescence:
                # remove states that are all the same (i.e. '111')
                states_to_quiescent = [s for s in states_to_quiescent if len(set(s)) != 1]
            if len(states_to_quiescent) == 0:
                break
            state_to_perturb = random.choice(states_to_quiescent)
            other_states = [x for x in range(0, k) if x != quiescent_state]
            rule_table[state_to_perturb] = random.choice(other_states)
            if isotropic:
                state_to_perturb_reversed = state_to_perturb[::-1]
                rule_table[state_to_perturb_reversed] = rule_table[state_to_perturb]
    return rule_table, actual_lambda()


 

========== FILE: cellpylib/sandpile.py ==========

from .ca_functions import BaseRule


class Sandpile(BaseRule):
    """
    A rule that operates on von Neumann neighbourhoods with a radius of 1. A sandpile is a 2D cellular automaton and
    dynamical system that displays self-organized criticality. It was introduced by Bak, Tang and Wiesenfeld in 1987.
    """
    def __init__(self, rows, cols, is_closed_boundary=True):
        """
        Creates a Sandpile.

        :param rows: the number of rows in this 2D CA

        :param cols: the number of columns in this 2D CA

        :param is_closed_boundary: whether or not the sandpile's boundary is closed; if it is closed, then all the
               boundary cells will maintain a value of 0 (default is True)
        """
        self._K = 4  # this value is hard-coded because the neighbourhood type, "von Neumann", is fixed
        self._rows = rows
        self._cols = cols
        self._is_closed_boundary = is_closed_boundary
        self._grain_additions = []

    def add_grain(self, cell_index, timestep):
        """
        Drop a grain of sand at the given cell in the given timestep.

        :param cell_index: a 2-tuple representing the row index and column index of the cell that will have
                           a grain of sand added

        :param timestep: the timestep at which the grain addition will occur
        """
        self._grain_additions.append(_GrainAddition(cell_index, timestep))

    def _is_in_boundary(self, c):
        """
        Returns True if the given cell (as a 2-tuple, representing its coordinates) is a boundary cell.

        :param c: a 2-tuple representing the row- and column-index of the cell

        :return: True if the given cell is a boundary cell, False otherwise
        """
        return c[0] == 0 or c[0] == self._rows - 1 or c[1] == 0 or c[1] == self._cols - 1

    def __call__(self, n, c, t):
        """
        The Sandpile rule to apply.

        :param n: the neighbourhood

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the activity of the current cell at the next timestep
        """
        if self._is_closed_boundary and self._is_in_boundary(c):
            return 0  # closed boundary conditions

        for grain_addition in self._grain_additions:
            if t == grain_addition.timestep and c == grain_addition.cell_index:
                return n[1][1] + 1

        # this cell's activity is the value of the center of the von Neumann neighbourhood
        current_activity = n[1][1]
        new_activity = current_activity

        # this assumes a von Neumann neighbourhood of radius 1
        neighbour_activities = [n[0][1], n[1][0], n[1][2], n[2][1]]

        for neighbour_activity in neighbour_activities:

            if neighbour_activity >= self._K:
                new_activity += 1

        if current_activity >= self._K:
            new_activity -= self._K

        return new_activity


class _GrainAddition:
    """
    A representation of the addition of a grain of sand to the sandpile.
    """
    def __init__(self, cell_index, timestep):
        """
        Create an instance of a `_GrainAddition`.

        :param cell_index: the index of the cell that will have a grain of sand added

        :param timestep: the timestep at which the grain addition occurs
        """
        self.cell_index = cell_index
        self.timestep = timestep


 

========== FILE: cellpylib/sdsr_loop.py ==========

import numpy as np
from .langtons_loop import LangtonsLoop


class SDSRLoop(LangtonsLoop):
    """
    An implementation of H. Sayama's SDSR loop. For more information, see:

    .. code-block:: text

       Sayama, H. (1998). Constructing evolutionary systems on a simple deterministic cellular automata space.
       PhD, University of Tokyo, Department of Information Science.
    """
    def __init__(self):
        """
        Create an SDSR Loop.
        """
        super().__init__()

        # Define rule '11152->8' and its rotationally symmetric ones.
        self._rule_table[(1, 1, 1, 5, 2)] = 8
        self._rule_table[(1, 2, 1, 1, 5)] = 8
        self._rule_table[(1, 5, 2, 1, 1)] = 8
        self._rule_table[(1, 1, 5, 2, 1)] = 8

    def __call__(self, n, c, t):
        """
        From:
        Sayama, H. (1998). Constructing evolutionary systems on a simple deterministic cellular automata space.
        PhD, University of Tokyo, Department of Information Science.

        :param n: the neighbourhood

        :param c: the index of the current cell

        :param t: the current timestep

        :return: the activity of the current cell at the next timestep
        """
        current_activity = n[1][1]
        top = n[0][1]
        right = n[1][2]
        bottom = n[2][1]
        left = n[1][0]
        key = (current_activity, top, right, bottom, left)

        if key not in self._rule_table:
            trbl = (top, right, bottom, left)
            in_tube = self._is_in_tube(top, right, bottom, left)
            new_activity = None

            # Let 0->1 if it is in the tube and next to 1. Let all other 0s remain as is.
            if current_activity == 0:
                if in_tube and 1 in trbl:
                    new_activity = 1
                else:
                    new_activity = 0

            # Let 1->7 if it is in the tube and next to 7. Else, let 1->6 if it is in the tube and next to 6.
            # Else, let 1->4 if it is in the tube and next to 4.
            if current_activity == 1 and in_tube:
                if 7 in trbl:
                    new_activity = 7
                elif 6 in trbl:
                    new_activity = 6
                elif 4 in trbl:
                    new_activity = 4

            # Let 4,6,7->0 if it is in the tube and next to 0.
            if current_activity in (4, 6, 7) and in_tube and 0 in trbl:
                new_activity = 0

            # Let 2->1 if it is next to 3. Else, let 2 remain as is if it is next to another 2.
            if current_activity == 2 and 3 in trbl:
                new_activity = 1
            elif current_activity == 2 and 2 in trbl:
                new_activity = 2

            # Let 8->0 with no condition.
            if current_activity == 8:
                new_activity = 0

            # To all the undefined situations in whose four neighbourhood (TRBL) there is at least one site in state 8,
            # apply the following:
            if 8 in trbl:
                # Let 0,1->8 if there is at least one site in state 2,3,...,7 in its four neighbourhood (TRBL),
                # otherwise let 0->0 and 1->1
                if current_activity == 0 or current_activity == 1:
                    if np.any([i in trbl for i in (2, 3, 4, 5, 6, 7)]):
                        new_activity = 8
                    elif current_activity == 0:
                        new_activity = 0
                    elif current_activity == 1:
                        new_activity = 1

                # Let 2,3,5->0.
                if current_activity in (2, 3, 5):
                    new_activity = 0

                # Let 4,6,7->1.
                if current_activity in (4, 6, 7):
                    new_activity = 1

            # Clear up all the undefined situations by letting 0->0 and 1,2,...,7->8.
            if new_activity is None and current_activity == 0:
                new_activity = 0
            if new_activity is None and current_activity in (1, 2, 3, 4, 5, 6, 7):
                new_activity = 8

            return new_activity

        return self._rule_table[key]

    def _is_in_tube(self, top, right, bottom, left):
        k = 0
        for site in [top, right, bottom, left]:
            if site in (1, 2, 4, 6, 7):
                k += 1
        return k >= 2


 

========== FILE: demos/async_random_demo.py ==========

import cellpylib as cpl


cellular_automaton = cpl.init_simple2d(50, 50, val=0)


# During each timestep, we'll check each cell if it should be the one updated according to the
# update order. At the end of a timestep, the update order index is advanced, but if the
# update order is randomized at the end of each timestep, then this is equivalent to picking
# a cell randomly to update at each timestep.
apply_rule = cpl.AsynchronousRule(apply_rule=lambda n, c, t: 1, num_cells=(50, 50),
                                  randomize_each_cycle=True)

cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=50,
                                  neighbourhood='Moore', apply_rule=apply_rule)

cpl.plot2d_animate(cellular_automaton, interval=200, autoscale=True)


 

========== FILE: demos/asynchronous_demo.py ==========

import cellpylib as cpl

# implements the rule 60 sequential automaton from the NKS Notes on
#   Chapter 9, section 10: "Sequential cellular automata"
#   http://www.wolframscience.com/nks/notes-9-10--sequential-cellular-automata/
cellular_automaton = cpl.init_simple(21)

apply_rule = cpl.AsynchronousRule(apply_rule=lambda n, c, t: cpl.nks_rule(n, 60), update_order=range(1, 20))

cellular_automaton = cpl.evolve(cellular_automaton, timesteps=19*20, apply_rule=apply_rule)

# get every 19th row, including the first, as a cycle is completed every 19 rows
cpl.plot(cellular_automaton[::19])


 

========== FILE: demos/block2d_basic_ca_demo.py ==========

import cellpylib as cpl
import numpy as np

"""
2D Block CA from 
https://writings.stephenwolfram.com/2023/02/computational-foundations-for-the-second-law-of-thermodynamics/
"""

initial_conditions = np.array([[
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]])


def make_block2d_rule():
    base_rules = {
        ((0, 0), (0, 0)): ((0, 0), (0, 0)),
        ((0, 0), (0, 2)): ((2, 0), (0, 0)),
        ((2, 0), (0, 0)): ((0, 0), (0, 2)),
        ((0, 0), (2, 0)): ((0, 2), (0, 0)),
        ((0, 2), (0, 0)): ((0, 0), (2, 0)),
        ((0, 0), (2, 2)): ((2, 2), (0, 0)),
        ((2, 2), (0, 0)): ((0, 0), (2, 2)),
        ((0, 2), (0, 2)): ((2, 0), (2, 0)),
        ((2, 0), (2, 0)): ((0, 2), (0, 2)),
        ((0, 2), (2, 0)): ((2, 0), (0, 2)),
        ((2, 0), (0, 2)): ((0, 2), (2, 0)),
        ((0, 2), (2, 2)): ((2, 2), (2, 0)),
        ((2, 2), (2, 0)): ((0, 2), (2, 2)),
        ((2, 0), (2, 2)): ((2, 2), (0, 2)),
        ((2, 2), (0, 2)): ((2, 0), (2, 2)),
        ((2, 2), (2, 2)): ((2, 2), (2, 2)),
        # wall rules
        ((0, 0), (1, 1)): ((0, 0), (1, 1)),
        ((0, 1), (1, 1)): ((0, 1), (1, 1)),
        ((0, 2), (1, 1)): ((2, 0), (1, 1)),
        ((2, 0), (1, 1)): ((0, 2), (1, 1)),
        ((2, 1), (1, 1)): ((2, 1), (1, 1)),
        ((2, 2), (1, 1)): ((2, 2), (1, 1)),
        ((1, 1), (1, 1)): ((1, 1), (1, 1)),
    }
    rules = {}
    # add rotations
    for r, v in base_rules.items():
        rules[r] = v
        for _ in range(3):
            r = ((r[1][0], r[0][0]), (r[1][1], r[0][1]))
            v = ((v[1][0], v[0][0]), (v[1][1], v[0][1]))
            if r not in rules:
                rules[r] = v
    def _apply_rule(n, t):
        n = tuple(tuple(i) for i in n)
        return rules[n]
    return _apply_rule


ca = cpl.evolve2d_block(initial_conditions, block_size=(2, 2),
                        timesteps=40, apply_rule=make_block2d_rule())

cpl.plot2d_animate(ca)


 

========== FILE: demos/block2d_rotated_ca_demo.py ==========

import cellpylib as cpl
import numpy as np

"""
2D Block CA from 
https://writings.stephenwolfram.com/2023/02/computational-foundations-for-the-second-law-of-thermodynamics/
"""

initial_conditions = np.loadtxt('block2d_rotated_initial_conditions.txt', dtype=int)
initial_conditions = np.array([initial_conditions])


def make_block2d_rule():
    base_rules = {
        ((0, 0), (0, 0)): ((0, 0), (0, 0)),
        ((0, 0), (0, 2)): ((2, 0), (0, 0)),
        ((2, 0), (0, 0)): ((0, 0), (0, 2)),
        ((0, 0), (2, 0)): ((0, 2), (0, 0)),
        ((0, 2), (0, 0)): ((0, 0), (2, 0)),
        ((0, 0), (2, 2)): ((2, 2), (0, 0)),
        ((2, 2), (0, 0)): ((0, 0), (2, 2)),
        ((0, 2), (0, 2)): ((2, 0), (2, 0)),
        ((2, 0), (2, 0)): ((0, 2), (0, 2)),
        ((0, 2), (2, 0)): ((2, 0), (0, 2)),
        ((2, 0), (0, 2)): ((0, 2), (2, 0)),
        ((0, 2), (2, 2)): ((2, 2), (2, 0)),
        ((2, 2), (2, 0)): ((0, 2), (2, 2)),
        ((2, 0), (2, 2)): ((2, 2), (0, 2)),
        ((2, 2), (0, 2)): ((2, 0), (2, 2)),
        ((2, 2), (2, 2)): ((2, 2), (2, 2)),
        # wall rules
        ((0, 0), (1, 1)): ((0, 0), (1, 1)),
        ((0, 1), (1, 1)): ((0, 1), (1, 1)),
        ((0, 2), (1, 1)): ((2, 0), (1, 1)),
        ((2, 0), (1, 1)): ((0, 2), (1, 1)),
        ((2, 1), (1, 1)): ((2, 1), (1, 1)),
        ((2, 2), (1, 1)): ((2, 2), (1, 1)),
        ((1, 1), (1, 1)): ((1, 1), (1, 1)),
        ((1, 0), (0, 0)): ((1, 0), (0, 0)),
        ((1, 0), (0, 2)): ((1, 0), (0, 2)),
    }
    rules = {}
    # add rotations
    for r, v in base_rules.items():
        rules[r] = v
        for _ in range(3):
            r = ((r[1][0], r[0][0]), (r[1][1], r[0][1]))
            v = ((v[1][0], v[0][0]), (v[1][1], v[0][1]))
            if r not in rules:
                rules[r] = v
    def _apply_rule(n, t):
        n = tuple(tuple(i) for i in n)
        return rules[n]
    return _apply_rule


ca = cpl.evolve2d_block(initial_conditions, block_size=(2, 2),
                        timesteps=251, apply_rule=make_block2d_rule())

cpl.plot2d_animate(ca)


 

========== FILE: demos/block_ca1_demo.py ==========

import cellpylib as cpl
import numpy as np

"""
Block CA at the top of NKS page 460
"""

initial_conditions = np.array([[0]*13 + [1]*2 + [0]*201])


def block_rule(n, t):
    if n == (1, 1): return 1, 1
    elif n == (1, 0): return 1, 0
    elif n == (0, 1): return 0, 0
    elif n == (0, 0): return 0, 1


ca = cpl.evolve_block(initial_conditions, block_size=2, timesteps=200, apply_rule=block_rule)

cpl.plot(ca)


 

========== FILE: demos/block_ca2_demo.py ==========

import cellpylib as cpl
import numpy as np

"""
Block CA from 
https://writings.stephenwolfram.com/2023/02/computational-foundations-for-the-second-law-of-thermodynamics/
"""

initial_conditions = np.array([[0]*4 + [1] + [0]*7 + [1] + [0]*4 + [1] + [0]*20])


def block_rule(n, t):
    if n == (1, 1): return 1, 1
    elif n == (1, 0): return 0, 1
    elif n == (0, 1): return 1, 0
    elif n == (0, 0): return 0, 0


ca = cpl.evolve_block(initial_conditions, block_size=2, timesteps=100, apply_rule=block_rule)

cpl.plot(ca)


 

========== FILE: demos/block_ca3_demo.py ==========

import cellpylib as cpl
import numpy as np

"""
Block CA from 
https://writings.stephenwolfram.com/2023/02/computational-foundations-for-the-second-law-of-thermodynamics/
"""

initial_conditions = np.array([[0]*25 + [2]*17 + [0]*24])


def block_rule(n, t):
    if   n == (1, 1): return 2, 2
    elif n == (1, 0): return 1, 0
    elif n == (0, 1): return 0, 1
    elif n == (0, 0): return 0, 0
    elif n == (2, 2): return 1, 1
    elif n == (2, 0): return 0, 2
    elif n == (0, 2): return 2, 0
    elif n == (2, 1): return 2, 1
    elif n == (1, 2): return 1, 2


ca = cpl.evolve_block(initial_conditions, block_size=2, timesteps=200, apply_rule=block_rule)

cpl.plot(ca)


 

========== FILE: demos/block_ca4_demo.py ==========

import cellpylib as cpl
import numpy as np

"""
Block CA at the bottom of NKS page 462
"""

initial_conditions = np.array([[0]*30 + [2]*30 + [0]*30])


def block_rule(n, t):
    if   n == (1, 1): return 1, 1
    elif n == (1, 0): return 0, 2
    elif n == (0, 1): return 2, 0
    elif n == (0, 0): return 0, 0
    elif n == (2, 2): return 2, 2
    elif n == (2, 0): return 1, 0
    elif n == (0, 2): return 0, 1
    elif n == (2, 1): return 2, 1
    elif n == (1, 2): return 1, 2


ca = cpl.evolve_block(initial_conditions, block_size=2, timesteps=4500, apply_rule=block_rule)

cpl.plot(ca[-500:])


 

========== FILE: demos/cellpylib_demo.py ==========

import cellpylib as cpl

cellular_automaton = cpl.init_simple(200)
# cellular_automaton = cpl.init_random(200)

# evolve the cellular automaton for 100 time steps
cellular_automaton = cpl.evolve(cellular_automaton, timesteps=100, memoize=True,
                                apply_rule=lambda n, c, t: cpl.nks_rule(n, 30))

cpl.plot(cellular_automaton)


 

========== FILE: demos/cellpylib_memoization_demo.py ==========

import cellpylib as cpl
import time

start = time.time()
cpl.evolve(cpl.init_simple(1000), timesteps=500,
           apply_rule=lambda n, c, t: cpl.nks_rule(n, 30), memoize=True)

print(f"Elapsed: {time.time() - start:.2f} seconds")


 

========== FILE: demos/collatz_conjecture_demo.py ==========

import cellpylib as cpl
import numpy as np


initial = np.array([[17]], dtype=np.int)


def activity_rule(n, c, t):
    n = n[1]
    if n % 2 == 0:
        # number is even
        return n / 2
    else:
        return 3*n + 1


cellular_automaton = cpl.evolve(initial, apply_rule=activity_rule,
                                timesteps=lambda ca, t: True if ca[-1][0] != 1 else False)

print([i[0] for i in cellular_automaton])


 

========== FILE: demos/continuous_demo.py ==========

import math
from pprint import pprint

import numpy as np

import cellpylib as cpl

cellular_automaton = cpl.init_simple(200, dtype=np.float64)


# NKS page 157
def apply_rule(n, c, t):
    result = (sum(n) / len(n)) * (3 / 2)
    frac, whole = math.modf(result)
    return frac

cellular_automaton = cpl.evolve(cellular_automaton, timesteps=150,
                                apply_rule=apply_rule)

pprint(cellular_automaton[:6, 95:106].tolist(), width=100)

cpl.plot(cellular_automaton)


 

========== FILE: demos/ctrbl_rule_demo.py ==========

import cellpylib as cpl

ctrbl_rule = cpl.CTRBLRule(rule_table={
    (0, 1, 0, 0, 0): 1,
    (1, 1, 0, 0, 0): 0,
    (0, 0, 0, 0, 0): 0,
    (1, 0, 0, 0, 0): 1,
    (0, 0, 1, 1, 0): 0,
    (1, 1, 1, 1, 1): 1,
    (0, 1, 0, 1, 0): 0,
    (1, 1, 1, 0, 1): 1,
    (1, 0, 1, 0, 1): 1,
    (0, 1, 1, 1, 1): 1,
    (0, 0, 1, 1, 1): 0,
    (1, 1, 0, 0, 1): 1
}, add_rotations=True)

cellular_automaton = cpl.init_simple2d(rows=10, cols=10)

cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=60,
                                  apply_rule=ctrbl_rule, neighbourhood="von Neumann")

cpl.plot2d_animate(cellular_automaton)


 

========== FILE: demos/custom_rule_demo.py ==========

import cellpylib as cpl
from collections import defaultdict


class CustomRule(cpl.BaseRule):

    def __init__(self):
        self.count = defaultdict(int)

    def __call__(self, n, c, t):
        self.count[c] += 1
        return self.count[c]


rule = CustomRule()

cellular_automaton = cpl.init_simple(11)

cellular_automaton = cpl.evolve(cellular_automaton, timesteps=10,
                                apply_rule=rule)

cpl.plot(cellular_automaton)


 

========== FILE: demos/density_classification_demo.py ==========

import cellpylib as cpl
import numpy as np

cellular_automaton = cpl.init_random(149)

print("density of 1s: %s" % (np.count_nonzero(cellular_automaton) / 149))

# M. Mitchell et al. discovered this rule using a Genetic Algorithm
rule_number = 6667021275756174439087127638698866559

cellular_automaton = cpl.evolve(cellular_automaton, timesteps=149,
                                apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number), r=3)

cpl.plot(cellular_automaton)


 

========== FILE: demos/evoloop_demo.py ==========

import cellpylib as cpl

evoloop = cpl.Evoloop()

# the initial conditions consist of a single loop
cellular_automaton = evoloop.init_species13_loop((100, 100), 40, 15)

cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=700,
                                  apply_rule=evoloop, memoize="recursive")

cpl.plot2d_animate(cellular_automaton)


 

========== FILE: demos/fredkin_moore_demo.py ==========

import cellpylib as cpl
import numpy as np

cellular_automaton = cpl.init_simple2d(60, 60)
# the letter "E"
cellular_automaton[0][28][28] = 1
cellular_automaton[0][28][29] = 1
cellular_automaton[0][28][30] = 1
cellular_automaton[0][29][28] = 1
cellular_automaton[0][30][28] = 1
cellular_automaton[0][30][29] = 1
cellular_automaton[0][30][30] = 1
cellular_automaton[0][31][28] = 1
cellular_automaton[0][32][28] = 1
cellular_automaton[0][32][29] = 1
cellular_automaton[0][32][30] = 1

def activity_rule(n, c, t):
    current_activity = n[1][1]
    return (np.sum(n) - current_activity) % 2

cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=20,
                                  apply_rule=activity_rule, neighbourhood="Moore")

cpl.plot2d_animate(cellular_automaton, interval=350)


 

========== FILE: demos/fredkin_multicolor_demo.py ==========

import cellpylib as cpl
import numpy as np

cellular_automaton = cpl.init_simple2d(60, 60)
# the letter "E"
cellular_automaton[0][28][28] = 0
cellular_automaton[0][28][29] = 1
cellular_automaton[0][28][30] = 2
cellular_automaton[0][29][28] = 3
cellular_automaton[0][30][28] = 4
cellular_automaton[0][30][29] = 5
cellular_automaton[0][30][30] = 6
cellular_automaton[0][31][28] = 7
cellular_automaton[0][32][28] = 8
cellular_automaton[0][32][29] = 9
cellular_automaton[0][32][30] = 10

def activity_rule(n, c, t):
    current_activity = n[1][1]
    return (np.sum(n) - current_activity) % 11

cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=23,
                                  apply_rule=activity_rule, neighbourhood="von Neumann")

cpl.plot2d_animate(cellular_automaton, interval=350, colormap='viridis')


 

========== FILE: demos/fredkin_von_neumann_demo.py ==========

import cellpylib as cpl
import numpy as np

cellular_automaton = cpl.init_simple2d(60, 60)
# the letter "E"
cellular_automaton[0][28][28] = 1
cellular_automaton[0][28][29] = 1
cellular_automaton[0][28][30] = 1
cellular_automaton[0][29][28] = 1
cellular_automaton[0][30][28] = 1
cellular_automaton[0][30][29] = 1
cellular_automaton[0][30][30] = 1
cellular_automaton[0][31][28] = 1
cellular_automaton[0][32][28] = 1
cellular_automaton[0][32][29] = 1
cellular_automaton[0][32][30] = 1

def activity_rule(n, c, t):
    current_activity = n[1][1]
    return (np.sum(n) - current_activity) % 2

cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=20,
                                  apply_rule=activity_rule, neighbourhood="von Neumann")

cpl.plot2d_animate(cellular_automaton, interval=350)


 

========== FILE: demos/game_of_life_demo.py ==========

import cellpylib as cpl

# Glider
cellular_automaton = cpl.init_simple2d(60, 60)
cellular_automaton[:, [28,29,30,30], [30,31,29,31]] = 1

# Blinker
cellular_automaton[:, [40,40,40], [15,16,17]] = 1

# Light Weight Space Ship (LWSS)
cellular_automaton[:, [18,18,19,20,21,21,21,21,20], [45,48,44,44,44,45,46,47,48]] = 1

# evolve the cellular automaton for 60 time steps
cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=60, neighbourhood='Moore',
                                  apply_rule=cpl.game_of_life_rule, memoize="recursive")

cpl.plot2d_animate(cellular_automaton)


 

========== FILE: demos/hopfield_net_demo.py ==========

import numpy as np

import cellpylib as cpl

"""
Based on: http://neupy.com/2015/09/20/discrete_hopfield_network.html
"""
# patterns for training
zero = [
    0, 1, 1, 1, 0,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    0, 1, 1, 1, 0,
    0, 0, 0, 0, 0] # we add this last row so that we get an odd number of
                   #  total cells, so that we can specify a radius that includes exactly all the cells
one = [
    0, 1, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 0, 0, 0]

two = [
    1, 1, 1, 0, 0,
    0, 0, 0, 1, 0,
    0, 0, 0, 1, 0,
    0, 1, 1, 0, 0,
    1, 0, 0, 0, 0,
    1, 1, 1, 1, 1,
    0, 0, 0, 0, 0]
# replace the zeroes with -1 to make these vectors bipolar instead of binary
one = [-1 if x == 0 else x for x in one]
two = [-1 if x == 0 else x for x in two]
zero = [-1 if x == 0 else x for x in zero]

P = [zero, one, two]

# patterns to evaluate
half_zero = [
    0, 1, 1, 1, 0,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0]

half_one = [
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0]

half_two = [
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 1, 1, 0, 0,
    1, 0, 0, 0, 0,
    1, 1, 1, 1, 1,
    0, 0, 0, 0, 0]
half_zero = [-1 if x == 0 else x for x in half_zero]
half_one = [-1 if x == 0 else x for x in half_one]
half_two = [-1 if x == 0 else x for x in half_two]

cellular_automaton = np.array([half_two])

hopfield_net = cpl.HopfieldNet(num_cells=35)

hopfield_net.train(P)

cellular_automaton = cpl.evolve(cellular_automaton, timesteps=155,
                                apply_rule=hopfield_net.apply_rule, r=hopfield_net.r)

cpl.plot(hopfield_net.W)
cpl.plot2d_animate(np.reshape(cellular_automaton, (155, 7, 5)))


 

========== FILE: demos/langtons_loop_demo.py ==========

import cellpylib as cpl

langtons_loop = cpl.LangtonsLoop()

# the initial conditions consist of a single loop
cellular_automaton = langtons_loop.init_loops(1, (75, 75), [40], [25])

cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=500,
                                  apply_rule=langtons_loop, memoize="recursive")

cpl.plot2d_animate(cellular_automaton)


 

========== FILE: demos/memoization_comparison_demo.py ==========

import cellpylib as cpl
import time

start = time.time()
cpl.evolve(cpl.init_simple(600), timesteps=300,
           apply_rule=lambda n, c, t: cpl.nks_rule(n, 30))
print(f"Without memoization: {time.time() - start:.2f} seconds elapsed")

start = time.time()
cpl.evolve(cpl.init_simple(600), timesteps=300,
           apply_rule=lambda n, c, t: cpl.nks_rule(n, 30), memoize=True)
print(f"With memoization: {time.time() - start:.2f} seconds elapsed")


 

========== FILE: demos/reversible_demo.py ==========

import numpy as np

import cellpylib as cpl

# NKS page 437 - Rule 214R

# run the CA forward for 32 steps to get the initial condition for the next evolution
cellular_automaton = cpl.init_simple(63)
rule = cpl.ReversibleRule(cellular_automaton[0], 214)
cellular_automaton = cpl.evolve(cellular_automaton, timesteps=32, apply_rule=rule)

# use the last state of the CA as the initial, previous state for this evolution
rule = cpl.ReversibleRule(cellular_automaton[-1], 214)
cellular_automaton = np.array([cellular_automaton[-2]])
cellular_automaton = cpl.evolve(cellular_automaton, timesteps=62, apply_rule=rule)

cpl.plot(cellular_automaton)


 

========== FILE: demos/rule122R_entropy_demo.py ==========

import matplotlib.pyplot as plt
import numpy as np

import cellpylib as cpl

# NKS page 442 - Rule 122R
cellular_automaton = np.array([[0]*40 + [1]*20 + [0]*40])
rule = cpl.ReversibleRule(cellular_automaton[0], 122)
cellular_automaton = cpl.evolve(cellular_automaton, timesteps=1000, apply_rule=rule)

timestep = []
bientropies = []
shannon_entropies = []
average_cell_entropies = []
apentropies = []
for i, c in enumerate(cellular_automaton):
    timestep.append(i)
    bit_string = ''.join([str(x) for x in c])
    bientropies.append(cpl.ktbien(bit_string))
    shannon_entropies.append(cpl.shannon_entropy(bit_string))
    average_cell_entropies.append(cpl.average_cell_entropy(cellular_automaton[:i+1]))
    apentropies.append(cpl.apen(bit_string, m=1, r=0))
    print("%s, %s, %s, %s" % (i, bientropies[-1], shannon_entropies[-1], apentropies[-1]))

plt.figure(1)
plt.title("KTBiEn")
plt.plot(timestep, bientropies)

plt.figure(2)
plt.title("Shannon Information")
plt.plot(timestep, shannon_entropies)

plt.figure(3)
plt.title("ApEn")
plt.plot(timestep, apentropies)

plt.figure(4)
plt.title("Avg. Cell (Shannon) Entropy")
plt.plot(timestep, average_cell_entropies)

plt.figure(5)
cpl.plot(cellular_automaton)




 

========== FILE: demos/rule_table_demo.py ==========

import cellpylib as cpl

rule_table, actual_lambda, quiescent_state = cpl.random_rule_table(lambda_val=0.37, k=4, r=2,
                                                                   strong_quiescence=True, isotropic=True)

# cellular_automaton = cpl.init_simple(128, val=1)
cellular_automaton = cpl.init_random(128, k=4, n_randomized=20)

# evolve the cellular automaton for 200 time steps
cellular_automaton = cpl.evolve(cellular_automaton, timesteps=200,
                                apply_rule=lambda n, c, t: cpl.table_rule(n, rule_table), r=2)

cpl.plot(cellular_automaton)


 

========== FILE: demos/rule_table_walkthrough_demo.py ==========

import cellpylib as cpl

rule_table, actual_lambda, quiescent_state = cpl.random_rule_table(lambda_val=0.0, k=4, r=2,
                                                                   strong_quiescence=True, isotropic=True)

lambda_vals = [0.15, 0.37, 0.75]
ca_list = []
titles = []
for i in range(0, 3):
    # cellular_automaton = cpl.init_simple(128, val=1)
    cellular_automaton = cpl.init_random(128, k=4)

    rule_table, actual_lambda = cpl.table_walk_through(rule_table, lambda_vals[i], k=4, r=2,
                                                       quiescent_state=quiescent_state, strong_quiescence=True)
    print(actual_lambda)

    # evolve the cellular automaton for 200 time steps
    cellular_automaton = cpl.evolve(cellular_automaton, timesteps=200,
                                    apply_rule=lambda n, c, t: cpl.table_rule(n, rule_table), r=2)

    ca_list.append(cellular_automaton)
    avg_cell_entropy = cpl.average_cell_entropy(cellular_automaton)
    avg_mutual_information = cpl.average_mutual_information(cellular_automaton)
    titles.append(r'$\lambda$ = %s, $\widebar{H}$ = %s, $\widebar{I}$ = %s' %
                  (lambda_vals[i], "{:.4}".format(avg_cell_entropy), "{:.4}".format(avg_mutual_information)))

cpl.plot_multiple(ca_list, titles)


 

========== FILE: demos/sandpile_add_grain_demo.py ==========

import cellpylib as cpl
import numpy as np


n_rows = 45
n_cols = 45
sandpile = cpl.Sandpile(n_rows, n_cols)
sandpile.add_grain(cell_index=(23, 23), timestep=1)

initial = np.loadtxt('sandpile_add_grain_demo.txt', dtype=int)
initial = np.array([initial])

ca = cpl.evolve2d(initial, timesteps=cpl.until_fixed_point(),
                  apply_rule=sandpile, neighbourhood="von Neumann")

print("Number of timesteps to reach fixed point: %s" % len(ca))
cpl.plot2d_animate(ca)


 

========== FILE: demos/sandpile_demo.py ==========

import cellpylib as cpl
import numpy as np


n_rows = 45
n_cols = 45
sandpile = cpl.Sandpile(n_rows, n_cols)

initial = np.random.randint(5, size=n_rows*n_cols).reshape((1, n_rows, n_cols))
# we're using a closed boundary, so make the boundary cells 0
initial[0, 0, :], initial[0, n_rows-1, :], initial[0, :, 0], initial[0, :, n_cols-1] = 0, 0, 0, 0

ca = cpl.evolve2d(initial, timesteps=50, apply_rule=sandpile, neighbourhood="von Neumann")

cpl.plot2d_animate(ca)


 

========== FILE: demos/sandpile_dynamic_demo.py ==========

import cellpylib as cpl
import numpy as np
np.random.seed(0)


n_rows = 45
n_cols = 45
sandpile = cpl.Sandpile(n_rows, n_cols)

initial = np.random.randint(5, size=n_rows*n_cols).reshape((1, n_rows, n_cols))
# we're using a closed boundary, so make the boundary cells 0
initial[0, 0, :], initial[0, n_rows-1, :], initial[0, :, 0], initial[0, :, n_cols-1] = 0, 0, 0, 0

ca = cpl.evolve2d(initial, timesteps=cpl.until_fixed_point(),
                  apply_rule=sandpile, neighbourhood="von Neumann")

print("Number of timesteps to reach fixed point: %s" % len(ca))
cpl.plot2d_animate(ca)


 

========== FILE: demos/sandpile_growing_demo.py ==========

import cellpylib as cpl

"""
We repeatedly drop a grain of sand in the middle, allowing the sandpile to grow. 
After a grain is dropped, the system is allowed to evolve until a fixed point, 
where no further change occurs, before the next grain is dropped.
"""
n = 50
sandpile = cpl.Sandpile(n, n)
ca = cpl.init_simple2d(n, n, val=5)

for i in range(300):
    ca[-1, n//2, n//2] += 1
    ca = cpl.evolve2d(ca, apply_rule=sandpile,
                      timesteps=cpl.until_fixed_point(), neighbourhood='Moore')

cpl.plot2d_animate(ca)


 

========== FILE: demos/sdsr_loop_demo.py ==========

import cellpylib as cpl

sdsr_loop = cpl.SDSRLoop()

# the initial conditions consist of a single loop
cellular_automaton = sdsr_loop.init_loops(1, (100, 100), [40], [40])

cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=700,
                                  apply_rule=sdsr_loop, memoize="recursive")

cpl.plot2d_animate(cellular_automaton)


 

========== FILE: demos/totalistic_2d_demo.py ==========

import cellpylib as cpl

cellular_automaton = cpl.init_simple2d(60, 60)

# evolve the cellular automaton for 30 time steps
cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=30, neighbourhood='Moore',
                                  apply_rule=lambda n, c, t: cpl.totalistic_rule(n, k=2, rule=126))

cpl.plot2d(cellular_automaton)


 

========== FILE: demos/totalistic_demo.py ==========

import cellpylib as cpl

cellular_automaton = cpl.init_simple(200)
# cellular_automaton = cpl.init_random(200, k=3)

# evolve the cellular automaton for 100 time steps
cellular_automaton = cpl.evolve(cellular_automaton, timesteps=100,
                                apply_rule=lambda n, c, t: cpl.totalistic_rule(n, k=3, rule=777))

cpl.plot(cellular_automaton)


 

========== FILE: demos/wireworld_diodes_demo.py ==========

import cellpylib as cpl
import numpy as np
from matplotlib.colors import ListedColormap


def wireworld_rule(n, c, t):
    current_activity = n[1][1]
    if current_activity == 0:  # empty
        return 0
    if current_activity == 1:  # electron head
        return 2
    if current_activity == 2:  # electron tail
        return 3
    if current_activity == 3:  # conductor
        electron_head_count = np.count_nonzero(n == 1)
        return 1 if electron_head_count == 1 or electron_head_count == 2 else 3


cellular_automata = np.array([[
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0],
    [2, 1, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3],
    [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0],
    [2, 1, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3],
    [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]])

cellular_automata = cpl.evolve2d(cellular_automata, timesteps=15,
                                 apply_rule=wireworld_rule, neighbourhood="Moore")

cpl.plot2d_animate(cellular_automata, show_grid=True, show_margin=False, scale=0.3,
                   colormap=ListedColormap(["black", "blue", "red", "yellow"]))

 

========== FILE: demos/wireworld_xor_demo.py ==========

import cellpylib as cpl
import numpy as np
from matplotlib.colors import ListedColormap


def wireworld_rule(n, c, t):
    current_activity = n[1][1]
    if current_activity == 0:  # empty
        return 0
    if current_activity == 1:  # electron head
        return 2
    if current_activity == 2:  # electron tail
        return 3
    if current_activity == 3:  # conductor
        electron_head_count = np.count_nonzero(n == 1)
        return 1 if electron_head_count == 1 or electron_head_count == 2 else 3


cellular_automata = np.array([[
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 3, 1, 2, 3, 3, 3, 3, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 3, 3, 2],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0],
    [0, 0, 0, 3, 3, 2, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],
    [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]])

cellular_automata = cpl.evolve2d(cellular_automata, timesteps=25,
                                 apply_rule=wireworld_rule, neighbourhood="Moore")

cpl.plot2d_animate(cellular_automata, show_grid=True, show_margin=False, scale=0.3,
                   colormap=ListedColormap(["black", "blue", "red", "yellow"]))


 

========== FILE: doc/conf.py ==========

# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
import os
import sys
sys.path.insert(0, os.path.abspath('..'))
import sphinx_rtd_theme

# -- Project information -----------------------------------------------------

project = 'CellPyLib'
copyright = '2023, Luis M. Antunes'
author = 'Luis M. Antunes'


# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    "sphinx_rtd_theme",
    "sphinx.ext.autodoc",
    "sphinx-prompt"
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = "sphinx_rtd_theme"
html_copy_source = False
html_show_sourcelink = False

master_doc = "index"

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
add_module_names = False

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']
# html_logo = '_static/logo.png'


 

========== FILE: tests/__init__.py ==========



 

========== FILE: tests/test_apen.py ==========

import unittest

import pytest
import numpy as np

import cellpylib as cpl


class TestApproximateEntropy(unittest.TestCase):

    def test_apen_string(self):
        self.assertAlmostEqual(cpl.apen('112012210'), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen('200022211'), 0.6720110042418417)
        self.assertAlmostEqual(cpl.apen('210222001'), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen('101211011'), 0.7108955985334597)
        self.assertAlmostEqual(cpl.apen('102012212'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('101221002'), 0.8075424578717401)
        self.assertAlmostEqual(cpl.apen('111002012'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('202122111'), 0.7679050283924354)
        self.assertAlmostEqual(cpl.apen('011101220'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('011220201'), 0.6342556627317537)
        self.assertAlmostEqual(cpl.apen('222100001'), 0.4333181911312869)
        self.assertAlmostEqual(cpl.apen('212112021'), 0.5292122152818808)
        self.assertAlmostEqual(cpl.apen('020210222'), 0.5572868307502927)
        self.assertAlmostEqual(cpl.apen('110201211'), 0.9111277563603284)
        self.assertAlmostEqual(cpl.apen('022220112'), 0.6724349432497736)
        self.assertAlmostEqual(cpl.apen('111101112'), 0.38980394055976986)
        self.assertAlmostEqual(cpl.apen('120211111'), 0.5376088033934733)
        self.assertAlmostEqual(cpl.apen('221022012'), 0.9111277563603284)
        self.assertAlmostEqual(cpl.apen('020220021'), 0.5292122152818806)
        self.assertAlmostEqual(cpl.apen('000022102'), 0.5572868307502927)
        self.assertAlmostEqual(cpl.apen('001120021'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('120020002'), 0.3840000356103066)
        self.assertAlmostEqual(cpl.apen('121111011'), 0.7025554552711372)
        self.assertAlmostEqual(cpl.apen('002222201'), 0.4494060535808746)
        self.assertAlmostEqual(cpl.apen('220200202'), 0.5685207485814306)
        self.assertAlmostEqual(cpl.apen('011021100'), 0.7679050283924354)
        self.assertAlmostEqual(cpl.apen('122100221'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('002110121'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('020000220'), 0.6843741748545092)
        self.assertAlmostEqual(cpl.apen('011221122'), 0.594618233252449)
        self.assertAlmostEqual(cpl.apen('022121011'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('100212002'), 0.6720110042418421)
        self.assertAlmostEqual(cpl.apen('111101211'), 0.7025554552711372)
        self.assertAlmostEqual(cpl.apen('002010020'), 0.7108955985334596)
        self.assertAlmostEqual(cpl.apen('200211210'), 0.8075424578717401)
        self.assertAlmostEqual(cpl.apen('221101201'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('000021121'), 0.4333181911312871)
        self.assertAlmostEqual(cpl.apen('002110011'), 0.7679050283924354)
        self.assertAlmostEqual(cpl.apen('021210020'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('011212010'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('112012201'), 0.49872420910185533)
        self.assertAlmostEqual(cpl.apen('121012110'), 0.5645541660803557)
        self.assertAlmostEqual(cpl.apen('220121021'), 0.8452977993818285)
        self.assertAlmostEqual(cpl.apen('202011012'), 0.6342556627317537)
        self.assertAlmostEqual(cpl.apen('002101201'), 0.8452977993818285)
        self.assertAlmostEqual(cpl.apen('220002100'), 0.7305736258902786)
        self.assertAlmostEqual(cpl.apen('210021021'), 0.22227605448121235)
        self.assertAlmostEqual(cpl.apen('122201001'), 0.6342556627317537)
        self.assertAlmostEqual(cpl.apen('012210220'), 0.8452977993818285)
        self.assertAlmostEqual(cpl.apen('201200120'), 0.260031395991301)
        self.assertAlmostEqual(cpl.apen('112102202'), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen('221120022'), 0.9111277563603284)
        self.assertAlmostEqual(cpl.apen('021000021'), 0.3258613529698009)
        self.assertAlmostEqual(cpl.apen('100222220'), 0.4494060535808748)
        self.assertAlmostEqual(cpl.apen('021010121'), 0.49872420910185555)
        self.assertAlmostEqual(cpl.apen('221202222'), 0.7025554552711372)
        self.assertAlmostEqual(cpl.apen('221012222'), 0.5376088033934734)
        self.assertAlmostEqual(cpl.apen('000122100'), 0.6724349432497738)
        self.assertAlmostEqual(cpl.apen('011020211'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('220112002'), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen('020002222'), 0.6339267665519992)
        self.assertAlmostEqual(cpl.apen('212210200'), 0.8452977993818285)
        self.assertAlmostEqual(cpl.apen('010120120'), 0.26003139599130076)
        self.assertAlmostEqual(cpl.apen('010101100'), 0.5685207485814302)
        self.assertAlmostEqual(cpl.apen('101101002'), 0.5292122152818806)
        self.assertAlmostEqual(cpl.apen('222111100'), 0.4333181911312869)
        self.assertAlmostEqual(cpl.apen('011121010'), 0.622692848720861)
        self.assertAlmostEqual(cpl.apen('100011011'), 0.6993327845225673)
        self.assertAlmostEqual(cpl.apen('020021100'), 0.737840961220342)
        self.assertAlmostEqual(cpl.apen('220100102'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('000110212'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('200101100'), 0.622692848720861)
        self.assertAlmostEqual(cpl.apen('102001022'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('111122121'), 0.6843741748545092)
        self.assertAlmostEqual(cpl.apen('101210102'), 0.4333181911312871)
        self.assertAlmostEqual(cpl.apen('110000022'), 0.39126737094036934)
        self.assertAlmostEqual(cpl.apen('211120210'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('012011200'), 0.49872420910185533)
        self.assertAlmostEqual(cpl.apen('221211112'), 0.6339267665519991)
        self.assertAlmostEqual(cpl.apen('101112110'), 0.6454895805628911)
        self.assertAlmostEqual(cpl.apen('110222121'), 0.7679050283924354)
        self.assertAlmostEqual(cpl.apen('010002011'), 0.7959796438608473)
        self.assertAlmostEqual(cpl.apen('200011102'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('121200001'), 0.4333181911312871)
        self.assertAlmostEqual(cpl.apen('110011121'), 0.818776375702878)
        self.assertAlmostEqual(cpl.apen('001201021'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('101222022'), 0.6724349432497736)
        self.assertAlmostEqual(cpl.apen('212101102'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('201220200'), 0.7024990104218669)
        self.assertAlmostEqual(cpl.apen('022100020'), 0.7959796438608473)
        self.assertAlmostEqual(cpl.apen('200112200'), 0.6720110042418417)
        self.assertAlmostEqual(cpl.apen('201211000'), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen('000101202'), 0.737840961220342)
        self.assertAlmostEqual(cpl.apen('100211110'), 0.557286830750293)
        self.assertAlmostEqual(cpl.apen('122000022'), 0.5292122152818806)
        self.assertAlmostEqual(cpl.apen('102221002'), 0.49872420910185555)
        self.assertAlmostEqual(cpl.apen('202110020'), 0.6720110042418419)
        self.assertAlmostEqual(cpl.apen('002101202'), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen('120021201'), 0.6342556627317537)
        self.assertAlmostEqual(cpl.apen('010122022'), 0.6720110042418419)

    def test_apen_list(self):
        self.assertAlmostEqual(cpl.apen([1, 1, 2, 0, 1, 2, 2, 1, 0]), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen([2, 0, 0, 0, 2, 2, 2, 1, 1]), 0.6720110042418417)
        self.assertAlmostEqual(cpl.apen([2, 1, 0, 2, 2, 2, 0, 0, 1]), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen([1, 0, 1, 2, 1, 1, 0, 1, 1]), 0.7108955985334597)
        self.assertAlmostEqual(cpl.apen([1, 0, 2, 0, 1, 2, 2, 1, 2]), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen([1, 0, 1, 2, 2, 1, 0, 0, 2]), 0.8075424578717401)

    def test_apen_ndarray(self):
        self.assertAlmostEqual(cpl.apen(np.array([1, 1, 2, 0, 1, 2, 2, 1, 0])), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen(np.array([2, 0, 0, 0, 2, 2, 2, 1, 1])), 0.6720110042418417)
        self.assertAlmostEqual(cpl.apen(np.array([2, 1, 0, 2, 2, 2, 0, 0, 1])), 0.845297799381828)
        self.assertAlmostEqual(cpl.apen(np.array([1, 0, 1, 2, 1, 1, 0, 1, 1])), 0.7108955985334597)
        self.assertAlmostEqual(cpl.apen(np.array([1, 0, 2, 0, 1, 2, 2, 1, 2])), 0.8452977993818283)
        self.assertAlmostEqual(cpl.apen(np.array([1, 0, 1, 2, 2, 1, 0, 0, 2])), 0.8075424578717401)

    def test_apen_unsupported_sequence_type(self):
        with pytest.raises(Exception) as e:
            cpl.apen({1, 2, 3})
        self.assertTrue("unsupported sequence type: <class 'set'>" in str(e.value))


 

========== FILE: tests/test_bien.py ==========

import unittest

import cellpylib as cpl


class TestBiEntropy(unittest.TestCase):

    def test_binary_derivative(self):
        self.assertEqual(cpl.binary_derivative('01010101'), '1111111')
        self.assertEqual(cpl.binary_derivative('1111111'), '000000')
        self.assertEqual(cpl.binary_derivative('000000'), '00000')
        self.assertEqual(cpl.binary_derivative('00000'), '0000')
        self.assertEqual(cpl.binary_derivative('0000'), '000')
        self.assertEqual(cpl.binary_derivative('000'), '00')
        self.assertEqual(cpl.binary_derivative('00'), '0')
        self.assertEqual(cpl.binary_derivative('0'), '')
        self.assertEqual(cpl.binary_derivative('00010001'), '0011001')
        self.assertEqual(cpl.binary_derivative('0011001'), '010101')
        self.assertEqual(cpl.binary_derivative('010101'), '11111')
        self.assertEqual(cpl.binary_derivative('11111'), '0000')
        self.assertEqual(cpl.binary_derivative('00011111'), '0010000')
        self.assertEqual(cpl.binary_derivative('0010000'), '011000')
        self.assertEqual(cpl.binary_derivative('011000'), '10100')
        self.assertEqual(cpl.binary_derivative('10100'), '1110')
        self.assertEqual(cpl.binary_derivative('1110'), '001')
        self.assertEqual(cpl.binary_derivative('001'), '01')
        self.assertEqual(cpl.binary_derivative('01'), '1')
        self.assertEqual(cpl.binary_derivative('1'), '')

    def test_bien(self):
        # 2-bit strings
        self.assertEqual(cpl.bien('00'), 0.0)
        self.assertEqual(cpl.bien('01'), 1.0)
        self.assertEqual(cpl.bien('10'), 1.0)
        self.assertEqual(cpl.bien('11'), 0.0)
        # 4-bit strings, asserts equality to 7 decimal places
        self.assertAlmostEqual(cpl.bien('0000'), 0.0)
        self.assertAlmostEqual(cpl.bien('0001'), 0.9496956846525874)
        self.assertAlmostEqual(cpl.bien('0010'), 0.9496956846525874)
        self.assertAlmostEqual(cpl.bien('0011'), 0.40522738115842555)
        self.assertAlmostEqual(cpl.bien('0100'), 0.9496956846525874)
        self.assertAlmostEqual(cpl.bien('0101'), 0.14285714285714285)
        self.assertAlmostEqual(cpl.bien('0110'), 0.40522738115842555)
        self.assertAlmostEqual(cpl.bien('0111'), 0.9496956846525874)
        self.assertAlmostEqual(cpl.bien('1000'), 0.9496956846525874)
        self.assertAlmostEqual(cpl.bien('1001'), 0.40522738115842555)
        self.assertAlmostEqual(cpl.bien('1010'), 0.14285714285714285)
        self.assertAlmostEqual(cpl.bien('1011'), 0.9496956846525874)
        self.assertAlmostEqual(cpl.bien('1100'), 0.40522738115842555)
        self.assertAlmostEqual(cpl.bien('1101'), 0.9496956846525874)
        self.assertAlmostEqual(cpl.bien('1110'), 0.9496956846525874)
        self.assertAlmostEqual(cpl.bien('1111'), 0.0)
        # 8-bit strings, asserts equality to 7 decimal places
        self.assertAlmostEqual(cpl.bien('00000000'), 0.0)
        self.assertAlmostEqual(cpl.bien('00000001'), 0.9170735521822547)
        self.assertAlmostEqual(cpl.bien('00000010'), 0.9370347771941213)
        self.assertAlmostEqual(cpl.bien('00000011'), 0.44747006666680555)
        self.assertAlmostEqual(cpl.bien('00000100'), 0.9454843334903775)
        self.assertAlmostEqual(cpl.bien('00000101'), 0.22952306172250708)
        self.assertAlmostEqual(cpl.bien('00000110'), 0.454318194570354)
        self.assertAlmostEqual(cpl.bien('00000111'), 0.9444447585278324)
        self.assertAlmostEqual(cpl.bien('00001000'), 0.9297978768247205)
        self.assertAlmostEqual(cpl.bien('00001001'), 0.4719276050543988)
        self.assertAlmostEqual(cpl.bien('00001010'), 0.22952306172250708)
        self.assertAlmostEqual(cpl.bien('00001011'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('00001100'), 0.45174483501301504)
        self.assertAlmostEqual(cpl.bien('00001101'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('00001110'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('00001111'), 0.10727664290566898)
        self.assertAlmostEqual(cpl.bien('00010000'), 0.9297978768247205)
        self.assertAlmostEqual(cpl.bien('00010001'), 0.053399483437225476)
        self.assertAlmostEqual(cpl.bien('00010010'), 0.4562411483887417)
        self.assertAlmostEqual(cpl.bien('00010011'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('00010100'), 0.23797261801876332)
        self.assertAlmostEqual(cpl.bien('00010101'), 0.9402699705777856)
        self.assertAlmostEqual(cpl.bien('00010110'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('00010111'), 0.45515378785140964)
        self.assertAlmostEqual(cpl.bien('00011000'), 0.46743129167867215)
        self.assertAlmostEqual(cpl.bien('00011001'), 0.9265064677305163)
        self.assertAlmostEqual(cpl.bien('00011010'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('00011011'), 0.23945861703877014)
        self.assertAlmostEqual(cpl.bien('00011100'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('00011101'), 0.45772714740874854)
        self.assertAlmostEqual(cpl.bien('00011110'), 0.1141247708092174)
        self.assertAlmostEqual(cpl.bien('00011111'), 0.9444447585278324)
        self.assertAlmostEqual(cpl.bien('00100000'), 0.9454843334903775)
        self.assertAlmostEqual(cpl.bien('00100001'), 0.4562411483887417)
        self.assertAlmostEqual(cpl.bien('00100010'), 0.053399483437225476)
        self.assertAlmostEqual(cpl.bien('00100011'), 0.9349560240267725)
        self.assertAlmostEqual(cpl.bien('00100100'), 0.4536677888314028)
        self.assertAlmostEqual(cpl.bien('00100101'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('00100110'), 0.9421929243961734)
        self.assertAlmostEqual(cpl.bien('00100111'), 0.23945861703877014)
        self.assertAlmostEqual(cpl.bien('00101000'), 0.23797261801876332)
        self.assertAlmostEqual(cpl.bien('00101001'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('00101010'), 0.920308745565919)
        self.assertAlmostEqual(cpl.bien('00101011'), 0.468917290698679)
        self.assertAlmostEqual(cpl.bien('00101100'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('00101101'), 0.1141247708092174)
        self.assertAlmostEqual(cpl.bien('00101110'), 0.45772714740874854)
        self.assertAlmostEqual(cpl.bien('00101111'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('00110000'), 0.45174483501301504)
        self.assertAlmostEqual(cpl.bien('00110001'), 0.9421929243961734)
        self.assertAlmostEqual(cpl.bien('00110010'), 0.9265064677305163)
        self.assertAlmostEqual(cpl.bien('00110011'), 0.023389419465106323)
        self.assertAlmostEqual(cpl.bien('00110100'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('00110101'), 0.4558041935903608)
        self.assertAlmostEqual(cpl.bien('00110110'), 0.2310090607425139)
        self.assertAlmostEqual(cpl.bien('00110111'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('00111000'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('00111001'), 0.2310090607425139)
        self.assertAlmostEqual(cpl.bien('00111010'), 0.47341360407440564)
        self.assertAlmostEqual(cpl.bien('00111011'), 0.9349560240267725)
        self.assertAlmostEqual(cpl.bien('00111100'), 0.1115514112518785)
        self.assertAlmostEqual(cpl.bien('00111101'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('00111110'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('00111111'), 0.44747006666680555)
        self.assertAlmostEqual(cpl.bien('01000000'), 0.9370347771941213)
        self.assertAlmostEqual(cpl.bien('01000001'), 0.23797261801876332)
        self.assertAlmostEqual(cpl.bien('01000010'), 0.4536677888314028)
        self.assertAlmostEqual(cpl.bien('01000011'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('01000100'), 0.053399483437225476)
        self.assertAlmostEqual(cpl.bien('01000101'), 0.9330330702083848)
        self.assertAlmostEqual(cpl.bien('01000110'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('01000111'), 0.45772714740874854)
        self.assertAlmostEqual(cpl.bien('01001000'), 0.4562411483887417)
        self.assertAlmostEqual(cpl.bien('01001001'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('01001010'), 0.9444447585278324)
        self.assertAlmostEqual(cpl.bien('01001011'), 0.1141247708092174)
        self.assertAlmostEqual(cpl.bien('01001100'), 0.9265064677305163)
        self.assertAlmostEqual(cpl.bien('01001101'), 0.468917290698679)
        self.assertAlmostEqual(cpl.bien('01001110'), 0.23945861703877014)
        self.assertAlmostEqual(cpl.bien('01001111'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('01010000'), 0.22952306172250708)
        self.assertAlmostEqual(cpl.bien('01010001'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('01010010'), 0.9444447585278324)
        self.assertAlmostEqual(cpl.bien('01010011'), 0.4558041935903608)
        self.assertAlmostEqual(cpl.bien('01010100'), 0.920308745565919)
        self.assertAlmostEqual(cpl.bien('01010101'), 0.007874015748031496)
        self.assertAlmostEqual(cpl.bien('01010110'), 0.4489560656868124)
        self.assertAlmostEqual(cpl.bien('01010111'), 0.9402699705777856)
        self.assertAlmostEqual(cpl.bien('01011000'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('01011001'), 0.4532308340330219)
        self.assertAlmostEqual(cpl.bien('01011010'), 0.10727664290566899)
        self.assertAlmostEqual(cpl.bien('01011011'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('01011100'), 0.47341360407440564)
        self.assertAlmostEqual(cpl.bien('01011101'), 0.9330330702083848)
        self.assertAlmostEqual(cpl.bien('01011110'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('01011111'), 0.22952306172250708)
        self.assertAlmostEqual(cpl.bien('01100000'), 0.454318194570354)
        self.assertAlmostEqual(cpl.bien('01100001'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('01100010'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('01100011'), 0.2310090607425139)
        self.assertAlmostEqual(cpl.bien('01100100'), 0.9421929243961734)
        self.assertAlmostEqual(cpl.bien('01100101'), 0.4532308340330219)
        self.assertAlmostEqual(cpl.bien('01100110'), 0.023389419465106323)
        self.assertAlmostEqual(cpl.bien('01100111'), 0.9265064677305163)
        self.assertAlmostEqual(cpl.bien('01101000'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('01101001'), 0.1115514112518785)
        self.assertAlmostEqual(cpl.bien('01101010'), 0.4489560656868124)
        self.assertAlmostEqual(cpl.bien('01101011'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('01101100'), 0.2310090607425139)
        self.assertAlmostEqual(cpl.bien('01101101'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('01101110'), 0.9349560240267725)
        self.assertAlmostEqual(cpl.bien('01101111'), 0.4719276050543988)
        self.assertAlmostEqual(cpl.bien('01110000'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('01110001'), 0.45515378785140964)
        self.assertAlmostEqual(cpl.bien('01110010'), 0.23945861703877014)
        self.assertAlmostEqual(cpl.bien('01110011'), 0.9421929243961734)
        self.assertAlmostEqual(cpl.bien('01110100'), 0.45772714740874854)
        self.assertAlmostEqual(cpl.bien('01110101'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('01110110'), 0.9349560240267725)
        self.assertAlmostEqual(cpl.bien('01110111'), 0.053399483437225476)
        self.assertAlmostEqual(cpl.bien('01111000'), 0.1141247708092174)
        self.assertAlmostEqual(cpl.bien('01111001'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('01111010'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('01111011'), 0.4562411483887417)
        self.assertAlmostEqual(cpl.bien('01111100'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('01111101'), 0.23797261801876332)
        self.assertAlmostEqual(cpl.bien('01111110'), 0.46743129167867215)
        self.assertAlmostEqual(cpl.bien('01111111'), 0.9170735521822547)
        self.assertAlmostEqual(cpl.bien('10000000'), 0.9170735521822547)
        self.assertAlmostEqual(cpl.bien('10000001'), 0.46743129167867215)
        self.assertAlmostEqual(cpl.bien('10000010'), 0.23797261801876332)
        self.assertAlmostEqual(cpl.bien('10000011'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('10000100'), 0.4562411483887417)
        self.assertAlmostEqual(cpl.bien('10000101'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('10000110'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('10000111'), 0.1141247708092174)
        self.assertAlmostEqual(cpl.bien('10001000'), 0.053399483437225476)
        self.assertAlmostEqual(cpl.bien('10001001'), 0.9349560240267725)
        self.assertAlmostEqual(cpl.bien('10001010'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('10001011'), 0.45772714740874854)
        self.assertAlmostEqual(cpl.bien('10001100'), 0.9421929243961734)
        self.assertAlmostEqual(cpl.bien('10001101'), 0.23945861703877014)
        self.assertAlmostEqual(cpl.bien('10001110'), 0.45515378785140964)
        self.assertAlmostEqual(cpl.bien('10001111'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('10010000'), 0.4719276050543988)
        self.assertAlmostEqual(cpl.bien('10010001'), 0.9349560240267725)
        self.assertAlmostEqual(cpl.bien('10010010'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('10010011'), 0.2310090607425139)
        self.assertAlmostEqual(cpl.bien('10010100'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('10010101'), 0.4489560656868124)
        self.assertAlmostEqual(cpl.bien('10010110'), 0.1115514112518785)
        self.assertAlmostEqual(cpl.bien('10010111'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('10011000'), 0.9265064677305163)
        self.assertAlmostEqual(cpl.bien('10011001'), 0.023389419465106323)
        self.assertAlmostEqual(cpl.bien('10011010'), 0.4532308340330219)
        self.assertAlmostEqual(cpl.bien('10011011'), 0.9421929243961734)
        self.assertAlmostEqual(cpl.bien('10011100'), 0.2310090607425139)
        self.assertAlmostEqual(cpl.bien('10011101'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('10011110'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('10011111'), 0.454318194570354)
        self.assertAlmostEqual(cpl.bien('10100000'), 0.22952306172250708)
        self.assertAlmostEqual(cpl.bien('10100001'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('10100010'), 0.9330330702083848)
        self.assertAlmostEqual(cpl.bien('10100011'), 0.47341360407440564)
        self.assertAlmostEqual(cpl.bien('10100100'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('10100101'), 0.10727664290566899)
        self.assertAlmostEqual(cpl.bien('10100110'), 0.4532308340330219)
        self.assertAlmostEqual(cpl.bien('10100111'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('10101000'), 0.9402699705777856)
        self.assertAlmostEqual(cpl.bien('10101001'), 0.4489560656868124)
        self.assertAlmostEqual(cpl.bien('10101010'), 0.007874015748031496)
        self.assertAlmostEqual(cpl.bien('10101011'), 0.920308745565919)
        self.assertAlmostEqual(cpl.bien('10101100'), 0.4558041935903608)
        self.assertAlmostEqual(cpl.bien('10101101'), 0.9444447585278324)
        self.assertAlmostEqual(cpl.bien('10101110'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('10101111'), 0.22952306172250708)
        self.assertAlmostEqual(cpl.bien('10110000'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('10110001'), 0.23945861703877014)
        self.assertAlmostEqual(cpl.bien('10110010'), 0.468917290698679)
        self.assertAlmostEqual(cpl.bien('10110011'), 0.9265064677305163)
        self.assertAlmostEqual(cpl.bien('10110100'), 0.1141247708092174)
        self.assertAlmostEqual(cpl.bien('10110101'), 0.9444447585278324)
        self.assertAlmostEqual(cpl.bien('10110110'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('10110111'), 0.4562411483887417)
        self.assertAlmostEqual(cpl.bien('10111000'), 0.45772714740874854)
        self.assertAlmostEqual(cpl.bien('10111001'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('10111010'), 0.9330330702083848)
        self.assertAlmostEqual(cpl.bien('10111011'), 0.053399483437225476)
        self.assertAlmostEqual(cpl.bien('10111100'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('10111101'), 0.4536677888314028)
        self.assertAlmostEqual(cpl.bien('10111110'), 0.23797261801876332)
        self.assertAlmostEqual(cpl.bien('10111111'), 0.9370347771941213)
        self.assertAlmostEqual(cpl.bien('11000000'), 0.44747006666680555)
        self.assertAlmostEqual(cpl.bien('11000001'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('11000010'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('11000011'), 0.1115514112518785)
        self.assertAlmostEqual(cpl.bien('11000100'), 0.9349560240267725)
        self.assertAlmostEqual(cpl.bien('11000101'), 0.47341360407440564)
        self.assertAlmostEqual(cpl.bien('11000110'), 0.2310090607425139)
        self.assertAlmostEqual(cpl.bien('11000111'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('11001000'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('11001001'), 0.2310090607425139)
        self.assertAlmostEqual(cpl.bien('11001010'), 0.4558041935903608)
        self.assertAlmostEqual(cpl.bien('11001011'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('11001100'), 0.023389419465106323)
        self.assertAlmostEqual(cpl.bien('11001101'), 0.9265064677305163)
        self.assertAlmostEqual(cpl.bien('11001110'), 0.9421929243961734)
        self.assertAlmostEqual(cpl.bien('11001111'), 0.45174483501301504)
        self.assertAlmostEqual(cpl.bien('11010000'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('11010001'), 0.45772714740874854)
        self.assertAlmostEqual(cpl.bien('11010010'), 0.1141247708092174)
        self.assertAlmostEqual(cpl.bien('11010011'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('11010100'), 0.468917290698679)
        self.assertAlmostEqual(cpl.bien('11010101'), 0.920308745565919)
        self.assertAlmostEqual(cpl.bien('11010110'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('11010111'), 0.23797261801876332)
        self.assertAlmostEqual(cpl.bien('11011000'), 0.23945861703877014)
        self.assertAlmostEqual(cpl.bien('11011001'), 0.9421929243961734)
        self.assertAlmostEqual(cpl.bien('11011010'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('11011011'), 0.4536677888314028)
        self.assertAlmostEqual(cpl.bien('11011100'), 0.9349560240267725)
        self.assertAlmostEqual(cpl.bien('11011101'), 0.053399483437225476)
        self.assertAlmostEqual(cpl.bien('11011110'), 0.4562411483887417)
        self.assertAlmostEqual(cpl.bien('11011111'), 0.9454843334903775)
        self.assertAlmostEqual(cpl.bien('11100000'), 0.9444447585278324)
        self.assertAlmostEqual(cpl.bien('11100001'), 0.1141247708092174)
        self.assertAlmostEqual(cpl.bien('11100010'), 0.45772714740874854)
        self.assertAlmostEqual(cpl.bien('11100011'), 0.9487195268740418)
        self.assertAlmostEqual(cpl.bien('11100100'), 0.23945861703877014)
        self.assertAlmostEqual(cpl.bien('11100101'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('11100110'), 0.9265064677305163)
        self.assertAlmostEqual(cpl.bien('11100111'), 0.46743129167867215)
        self.assertAlmostEqual(cpl.bien('11101000'), 0.45515378785140964)
        self.assertAlmostEqual(cpl.bien('11101001'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('11101010'), 0.9402699705777856)
        self.assertAlmostEqual(cpl.bien('11101011'), 0.23797261801876332)
        self.assertAlmostEqual(cpl.bien('11101100'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('11101101'), 0.4562411483887417)
        self.assertAlmostEqual(cpl.bien('11101110'), 0.053399483437225476)
        self.assertAlmostEqual(cpl.bien('11101111'), 0.9297978768247205)
        self.assertAlmostEqual(cpl.bien('11110000'), 0.10727664290566898)
        self.assertAlmostEqual(cpl.bien('11110001'), 0.9512928864313808)
        self.assertAlmostEqual(cpl.bien('11110010'), 0.9532158402497685)
        self.assertAlmostEqual(cpl.bien('11110011'), 0.45174483501301504)
        self.assertAlmostEqual(cpl.bien('11110100'), 0.9506424806924296)
        self.assertAlmostEqual(cpl.bien('11110101'), 0.22952306172250708)
        self.assertAlmostEqual(cpl.bien('11110110'), 0.4719276050543988)
        self.assertAlmostEqual(cpl.bien('11110111'), 0.9297978768247205)
        self.assertAlmostEqual(cpl.bien('11111000'), 0.9444447585278324)
        self.assertAlmostEqual(cpl.bien('11111001'), 0.454318194570354)
        self.assertAlmostEqual(cpl.bien('11111010'), 0.22952306172250708)
        self.assertAlmostEqual(cpl.bien('11111011'), 0.9454843334903775)
        self.assertAlmostEqual(cpl.bien('11111100'), 0.44747006666680555)
        self.assertAlmostEqual(cpl.bien('11111101'), 0.9370347771941213)
        self.assertAlmostEqual(cpl.bien('11111110'), 0.9170735521822547)
        self.assertAlmostEqual(cpl.bien('11111111'), 0.0)

    def test_tbien(self):
        # 2-bit strings
        self.assertEqual(cpl.tbien('00'), 0.0)
        self.assertEqual(cpl.tbien('01'), 1.0)
        self.assertEqual(cpl.tbien('10'), 1.0)
        self.assertEqual(cpl.tbien('11'), 0.0)
        # 4-bit strings, asserts equality to 7 decimal places
        self.assertAlmostEqual(cpl.tbien('0000'), 0.0)
        self.assertAlmostEqual(cpl.tbien('0001'), 0.9305948708049089)
        self.assertAlmostEqual(cpl.tbien('0010'), 0.9305948708049089)
        self.assertAlmostEqual(cpl.tbien('0011'), 0.5355473378808682)
        self.assertAlmostEqual(cpl.tbien('0100'), 0.9305948708049089)
        self.assertAlmostEqual(cpl.tbien('0101'), 0.21810429198553155)
        self.assertAlmostEqual(cpl.tbien('0110'), 0.5355473378808682)
        self.assertAlmostEqual(cpl.tbien('0111'), 0.9305948708049089)
        self.assertAlmostEqual(cpl.tbien('1000'), 0.9305948708049089)
        self.assertAlmostEqual(cpl.tbien('1001'), 0.5355473378808682)
        self.assertAlmostEqual(cpl.tbien('1010'), 0.21810429198553155)
        self.assertAlmostEqual(cpl.tbien('1011'), 0.9305948708049089)
        self.assertAlmostEqual(cpl.tbien('1100'), 0.5355473378808682)
        self.assertAlmostEqual(cpl.tbien('1101'), 0.9305948708049089)
        self.assertAlmostEqual(cpl.tbien('1110'), 0.9305948708049089)
        self.assertAlmostEqual(cpl.tbien('1111'), 0.0)
        # 8-bit strings, asserts equality to 7 decimal places
        self.assertAlmostEqual(cpl.tbien('00000000'), 0.0)
        self.assertAlmostEqual(cpl.tbien('00000001'), 0.7930318630672043)
        self.assertAlmostEqual(cpl.tbien('00000010'), 0.8589468375430831)
        self.assertAlmostEqual(cpl.tbien('00000011'), 0.6813985994017482)
        self.assertAlmostEqual(cpl.tbien('00000100'), 0.8940170728237214)
        self.assertAlmostEqual(cpl.tbien('00000101'), 0.5563891001761716)
        self.assertAlmostEqual(cpl.tbien('00000110'), 0.7202007974767275)
        self.assertAlmostEqual(cpl.tbien('00000111'), 0.8927513204867304)
        self.assertAlmostEqual(cpl.tbien('00001000'), 0.8562234604151914)
        self.assertAlmostEqual(cpl.tbien('00001001'), 0.7706444709379511)
        self.assertAlmostEqual(cpl.tbien('00001010'), 0.5563891001761716)
        self.assertAlmostEqual(cpl.tbien('00001011'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('00001100'), 0.7095199614690969)
        self.assertAlmostEqual(cpl.tbien('00001101'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('00001110'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('00001111'), 0.3940627705450895)
        self.assertAlmostEqual(cpl.tbien('00010000'), 0.8562234604151914)
        self.assertAlmostEqual(cpl.tbien('00010001'), 0.28582053198265955)
        self.assertAlmostEqual(cpl.tbien('00010010'), 0.732850858529421)
        self.assertAlmostEqual(cpl.tbien('00010011'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('00010100'), 0.59145933545681)
        self.assertAlmostEqual(cpl.tbien('00010101'), 0.8858024472734408)
        self.assertAlmostEqual(cpl.tbien('00010110'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('00010111'), 0.7345054241526495)
        self.assertAlmostEqual(cpl.tbien('00011000'), 0.747313573877627)
        self.assertAlmostEqual(cpl.tbien('00011001'), 0.8606588959176042)
        self.assertAlmostEqual(cpl.tbien('00011010'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('00011011'), 0.6037947370876691)
        self.assertAlmostEqual(cpl.tbien('00011100'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('00011101'), 0.7451862601602801)
        self.assertAlmostEqual(cpl.tbien('00011110'), 0.43286496862006874)
        self.assertAlmostEqual(cpl.tbien('00011111'), 0.8927513204867304)
        self.assertAlmostEqual(cpl.tbien('00100000'), 0.8940170728237214)
        self.assertAlmostEqual(cpl.tbien('00100001'), 0.732850858529421)
        self.assertAlmostEqual(cpl.tbien('00100010'), 0.28582053198265955)
        self.assertAlmostEqual(cpl.tbien('00100011'), 0.8957291311982426)
        self.assertAlmostEqual(cpl.tbien('00100100'), 0.7221700225217904)
        self.assertAlmostEqual(cpl.tbien('00100101'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('00100110'), 0.8984525083261343)
        self.assertAlmostEqual(cpl.tbien('00100111'), 0.6037947370876691)
        self.assertAlmostEqual(cpl.tbien('00101000'), 0.59145933545681)
        self.assertAlmostEqual(cpl.tbien('00101001'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('00101010'), 0.819887472797562)
        self.assertAlmostEqual(cpl.tbien('00101011'), 0.7596489755084861)
        self.assertAlmostEqual(cpl.tbien('00101100'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('00101101'), 0.43286496862006874)
        self.assertAlmostEqual(cpl.tbien('00101110'), 0.7451862601602801)
        self.assertAlmostEqual(cpl.tbien('00101111'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('00110000'), 0.7095199614690969)
        self.assertAlmostEqual(cpl.tbien('00110001'), 0.8984525083261343)
        self.assertAlmostEqual(cpl.tbien('00110010'), 0.8606588959176042)
        self.assertAlmostEqual(cpl.tbien('00110011'), 0.1674302125437542)
        self.assertAlmostEqual(cpl.tbien('00110100'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('00110101'), 0.7325361991075866)
        self.assertAlmostEqual(cpl.tbien('00110110'), 0.5687245018070307)
        self.assertAlmostEqual(cpl.tbien('00110111'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('00111000'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('00111001'), 0.5687245018070307)
        self.assertAlmostEqual(cpl.tbien('00111010'), 0.7829798725688102)
        self.assertAlmostEqual(cpl.tbien('00111011'), 0.8957291311982426)
        self.assertAlmostEqual(cpl.tbien('00111100'), 0.4221841326124382)
        self.assertAlmostEqual(cpl.tbien('00111101'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('00111110'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('00111111'), 0.6813985994017482)
        self.assertAlmostEqual(cpl.tbien('01000000'), 0.8589468375430831)
        self.assertAlmostEqual(cpl.tbien('01000001'), 0.59145933545681)
        self.assertAlmostEqual(cpl.tbien('01000010'), 0.7221700225217904)
        self.assertAlmostEqual(cpl.tbien('01000011'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('01000100'), 0.28582053198265955)
        self.assertAlmostEqual(cpl.tbien('01000101'), 0.8830790701455491)
        self.assertAlmostEqual(cpl.tbien('01000110'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('01000111'), 0.7451862601602801)
        self.assertAlmostEqual(cpl.tbien('01001000'), 0.732850858529421)
        self.assertAlmostEqual(cpl.tbien('01001001'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('01001010'), 0.8927513204867304)
        self.assertAlmostEqual(cpl.tbien('01001011'), 0.43286496862006874)
        self.assertAlmostEqual(cpl.tbien('01001100'), 0.8606588959176042)
        self.assertAlmostEqual(cpl.tbien('01001101'), 0.7596489755084861)
        self.assertAlmostEqual(cpl.tbien('01001110'), 0.6037947370876691)
        self.assertAlmostEqual(cpl.tbien('01001111'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('01010000'), 0.5563891001761716)
        self.assertAlmostEqual(cpl.tbien('01010001'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('01010010'), 0.8927513204867304)
        self.assertAlmostEqual(cpl.tbien('01010011'), 0.7325361991075866)
        self.assertAlmostEqual(cpl.tbien('01010100'), 0.819887472797562)
        self.assertAlmostEqual(cpl.tbien('01010101'), 0.06536286053488224)
        self.assertAlmostEqual(cpl.tbien('01010110'), 0.6937340010326074)
        self.assertAlmostEqual(cpl.tbien('01010111'), 0.8858024472734408)
        self.assertAlmostEqual(cpl.tbien('01011000'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('01011001'), 0.721855363099956)
        self.assertAlmostEqual(cpl.tbien('01011010'), 0.39406277054508954)
        self.assertAlmostEqual(cpl.tbien('01011011'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('01011100'), 0.7829798725688102)
        self.assertAlmostEqual(cpl.tbien('01011101'), 0.8830790701455491)
        self.assertAlmostEqual(cpl.tbien('01011110'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('01011111'), 0.5563891001761716)
        self.assertAlmostEqual(cpl.tbien('01100000'), 0.7202007974767275)
        self.assertAlmostEqual(cpl.tbien('01100001'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('01100010'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('01100011'), 0.5687245018070307)
        self.assertAlmostEqual(cpl.tbien('01100100'), 0.8984525083261343)
        self.assertAlmostEqual(cpl.tbien('01100101'), 0.721855363099956)
        self.assertAlmostEqual(cpl.tbien('01100110'), 0.1674302125437542)
        self.assertAlmostEqual(cpl.tbien('01100111'), 0.8606588959176042)
        self.assertAlmostEqual(cpl.tbien('01101000'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('01101001'), 0.4221841326124382)
        self.assertAlmostEqual(cpl.tbien('01101010'), 0.6937340010326074)
        self.assertAlmostEqual(cpl.tbien('01101011'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('01101100'), 0.5687245018070307)
        self.assertAlmostEqual(cpl.tbien('01101101'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('01101110'), 0.8957291311982426)
        self.assertAlmostEqual(cpl.tbien('01101111'), 0.7706444709379511)
        self.assertAlmostEqual(cpl.tbien('01110000'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('01110001'), 0.7345054241526495)
        self.assertAlmostEqual(cpl.tbien('01110010'), 0.6037947370876691)
        self.assertAlmostEqual(cpl.tbien('01110011'), 0.8984525083261343)
        self.assertAlmostEqual(cpl.tbien('01110100'), 0.7451862601602801)
        self.assertAlmostEqual(cpl.tbien('01110101'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('01110110'), 0.8957291311982426)
        self.assertAlmostEqual(cpl.tbien('01110111'), 0.28582053198265955)
        self.assertAlmostEqual(cpl.tbien('01111000'), 0.43286496862006874)
        self.assertAlmostEqual(cpl.tbien('01111001'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('01111010'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('01111011'), 0.732850858529421)
        self.assertAlmostEqual(cpl.tbien('01111100'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('01111101'), 0.59145933545681)
        self.assertAlmostEqual(cpl.tbien('01111110'), 0.747313573877627)
        self.assertAlmostEqual(cpl.tbien('01111111'), 0.7930318630672043)
        self.assertAlmostEqual(cpl.tbien('10000000'), 0.7930318630672043)
        self.assertAlmostEqual(cpl.tbien('10000001'), 0.747313573877627)
        self.assertAlmostEqual(cpl.tbien('10000010'), 0.59145933545681)
        self.assertAlmostEqual(cpl.tbien('10000011'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('10000100'), 0.732850858529421)
        self.assertAlmostEqual(cpl.tbien('10000101'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('10000110'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('10000111'), 0.43286496862006874)
        self.assertAlmostEqual(cpl.tbien('10001000'), 0.28582053198265955)
        self.assertAlmostEqual(cpl.tbien('10001001'), 0.8957291311982426)
        self.assertAlmostEqual(cpl.tbien('10001010'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('10001011'), 0.7451862601602801)
        self.assertAlmostEqual(cpl.tbien('10001100'), 0.8984525083261343)
        self.assertAlmostEqual(cpl.tbien('10001101'), 0.6037947370876691)
        self.assertAlmostEqual(cpl.tbien('10001110'), 0.7345054241526495)
        self.assertAlmostEqual(cpl.tbien('10001111'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('10010000'), 0.7706444709379511)
        self.assertAlmostEqual(cpl.tbien('10010001'), 0.8957291311982426)
        self.assertAlmostEqual(cpl.tbien('10010010'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('10010011'), 0.5687245018070307)
        self.assertAlmostEqual(cpl.tbien('10010100'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('10010101'), 0.6937340010326074)
        self.assertAlmostEqual(cpl.tbien('10010110'), 0.4221841326124382)
        self.assertAlmostEqual(cpl.tbien('10010111'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('10011000'), 0.8606588959176042)
        self.assertAlmostEqual(cpl.tbien('10011001'), 0.1674302125437542)
        self.assertAlmostEqual(cpl.tbien('10011010'), 0.721855363099956)
        self.assertAlmostEqual(cpl.tbien('10011011'), 0.8984525083261343)
        self.assertAlmostEqual(cpl.tbien('10011100'), 0.5687245018070307)
        self.assertAlmostEqual(cpl.tbien('10011101'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('10011110'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('10011111'), 0.7202007974767275)
        self.assertAlmostEqual(cpl.tbien('10100000'), 0.5563891001761716)
        self.assertAlmostEqual(cpl.tbien('10100001'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('10100010'), 0.8830790701455491)
        self.assertAlmostEqual(cpl.tbien('10100011'), 0.7829798725688102)
        self.assertAlmostEqual(cpl.tbien('10100100'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('10100101'), 0.39406277054508954)
        self.assertAlmostEqual(cpl.tbien('10100110'), 0.721855363099956)
        self.assertAlmostEqual(cpl.tbien('10100111'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('10101000'), 0.8858024472734408)
        self.assertAlmostEqual(cpl.tbien('10101001'), 0.6937340010326074)
        self.assertAlmostEqual(cpl.tbien('10101010'), 0.06536286053488224)
        self.assertAlmostEqual(cpl.tbien('10101011'), 0.819887472797562)
        self.assertAlmostEqual(cpl.tbien('10101100'), 0.7325361991075866)
        self.assertAlmostEqual(cpl.tbien('10101101'), 0.8927513204867304)
        self.assertAlmostEqual(cpl.tbien('10101110'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('10101111'), 0.5563891001761716)
        self.assertAlmostEqual(cpl.tbien('10110000'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('10110001'), 0.6037947370876691)
        self.assertAlmostEqual(cpl.tbien('10110010'), 0.7596489755084861)
        self.assertAlmostEqual(cpl.tbien('10110011'), 0.8606588959176042)
        self.assertAlmostEqual(cpl.tbien('10110100'), 0.43286496862006874)
        self.assertAlmostEqual(cpl.tbien('10110101'), 0.8927513204867304)
        self.assertAlmostEqual(cpl.tbien('10110110'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('10110111'), 0.732850858529421)
        self.assertAlmostEqual(cpl.tbien('10111000'), 0.7451862601602801)
        self.assertAlmostEqual(cpl.tbien('10111001'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('10111010'), 0.8830790701455491)
        self.assertAlmostEqual(cpl.tbien('10111011'), 0.28582053198265955)
        self.assertAlmostEqual(cpl.tbien('10111100'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('10111101'), 0.7221700225217904)
        self.assertAlmostEqual(cpl.tbien('10111110'), 0.59145933545681)
        self.assertAlmostEqual(cpl.tbien('10111111'), 0.8589468375430831)
        self.assertAlmostEqual(cpl.tbien('11000000'), 0.6813985994017482)
        self.assertAlmostEqual(cpl.tbien('11000001'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('11000010'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('11000011'), 0.4221841326124382)
        self.assertAlmostEqual(cpl.tbien('11000100'), 0.8957291311982426)
        self.assertAlmostEqual(cpl.tbien('11000101'), 0.7829798725688102)
        self.assertAlmostEqual(cpl.tbien('11000110'), 0.5687245018070307)
        self.assertAlmostEqual(cpl.tbien('11000111'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('11001000'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('11001001'), 0.5687245018070307)
        self.assertAlmostEqual(cpl.tbien('11001010'), 0.7325361991075866)
        self.assertAlmostEqual(cpl.tbien('11001011'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('11001100'), 0.1674302125437542)
        self.assertAlmostEqual(cpl.tbien('11001101'), 0.8606588959176042)
        self.assertAlmostEqual(cpl.tbien('11001110'), 0.8984525083261343)
        self.assertAlmostEqual(cpl.tbien('11001111'), 0.7095199614690969)
        self.assertAlmostEqual(cpl.tbien('11010000'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('11010001'), 0.7451862601602801)
        self.assertAlmostEqual(cpl.tbien('11010010'), 0.43286496862006874)
        self.assertAlmostEqual(cpl.tbien('11010011'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('11010100'), 0.7596489755084861)
        self.assertAlmostEqual(cpl.tbien('11010101'), 0.819887472797562)
        self.assertAlmostEqual(cpl.tbien('11010110'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('11010111'), 0.59145933545681)
        self.assertAlmostEqual(cpl.tbien('11011000'), 0.6037947370876691)
        self.assertAlmostEqual(cpl.tbien('11011001'), 0.8984525083261343)
        self.assertAlmostEqual(cpl.tbien('11011010'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('11011011'), 0.7221700225217904)
        self.assertAlmostEqual(cpl.tbien('11011100'), 0.8957291311982426)
        self.assertAlmostEqual(cpl.tbien('11011101'), 0.28582053198265955)
        self.assertAlmostEqual(cpl.tbien('11011110'), 0.732850858529421)
        self.assertAlmostEqual(cpl.tbien('11011111'), 0.8940170728237214)
        self.assertAlmostEqual(cpl.tbien('11100000'), 0.8927513204867304)
        self.assertAlmostEqual(cpl.tbien('11100001'), 0.43286496862006874)
        self.assertAlmostEqual(cpl.tbien('11100010'), 0.7451862601602801)
        self.assertAlmostEqual(cpl.tbien('11100011'), 0.9208726825540792)
        self.assertAlmostEqual(cpl.tbien('11100100'), 0.6037947370876691)
        self.assertAlmostEqual(cpl.tbien('11100101'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('11100110'), 0.8606588959176042)
        self.assertAlmostEqual(cpl.tbien('11100111'), 0.747313573877627)
        self.assertAlmostEqual(cpl.tbien('11101000'), 0.7345054241526495)
        self.assertAlmostEqual(cpl.tbien('11101001'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('11101010'), 0.8858024472734408)
        self.assertAlmostEqual(cpl.tbien('11101011'), 0.59145933545681)
        self.assertAlmostEqual(cpl.tbien('11101100'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('11101101'), 0.732850858529421)
        self.assertAlmostEqual(cpl.tbien('11101110'), 0.28582053198265955)
        self.assertAlmostEqual(cpl.tbien('11101111'), 0.8562234604151914)
        self.assertAlmostEqual(cpl.tbien('11110000'), 0.3940627705450895)
        self.assertAlmostEqual(cpl.tbien('11110001'), 0.9315535185617098)
        self.assertAlmostEqual(cpl.tbien('11110010'), 0.9442035796144033)
        self.assertAlmostEqual(cpl.tbien('11110011'), 0.7095199614690969)
        self.assertAlmostEqual(cpl.tbien('11110100'), 0.9335227436067727)
        self.assertAlmostEqual(cpl.tbien('11110101'), 0.5563891001761716)
        self.assertAlmostEqual(cpl.tbien('11110110'), 0.7706444709379511)
        self.assertAlmostEqual(cpl.tbien('11110111'), 0.8562234604151914)
        self.assertAlmostEqual(cpl.tbien('11111000'), 0.8927513204867304)
        self.assertAlmostEqual(cpl.tbien('11111001'), 0.7202007974767275)
        self.assertAlmostEqual(cpl.tbien('11111010'), 0.5563891001761716)
        self.assertAlmostEqual(cpl.tbien('11111011'), 0.8940170728237214)
        self.assertAlmostEqual(cpl.tbien('11111100'), 0.6813985994017482)
        self.assertAlmostEqual(cpl.tbien('11111101'), 0.8589468375430831)
        self.assertAlmostEqual(cpl.tbien('11111110'), 0.7930318630672043)
        self.assertAlmostEqual(cpl.tbien('11111111'), 0.0)

    def test_cyclic_binary_derivative(self):
        self.assertEqual(cpl.cyclic_binary_derivative('10101110'), '11110011')
        self.assertEqual(cpl.cyclic_binary_derivative('11110011'), '00010100')
        self.assertEqual(cpl.cyclic_binary_derivative('00010100'), '00111100')
        self.assertEqual(cpl.cyclic_binary_derivative('00111100'), '01000100')
        self.assertEqual(cpl.cyclic_binary_derivative('01000100'), '11001100')
        self.assertEqual(cpl.cyclic_binary_derivative('11001100'), '01010101')
        self.assertEqual(cpl.cyclic_binary_derivative('01010101'), '11111111')

    def test_ktbien(self):
        # 2-bit strings
        self.assertEqual(cpl.ktbien('00'), 0.0)
        self.assertEqual(cpl.ktbien('01'), 1.0)
        self.assertEqual(cpl.ktbien('10'), 1.0)
        self.assertEqual(cpl.ktbien('11'), 0.0)
        # other cases
        self.assertAlmostEqual(cpl.ktbien('10101110'), 0.9209131731629818)


 

========== FILE: tests/test_cellpylib.py ==========

import unittest

import numpy as np
import os
import ast
import pytest
import matplotlib

import cellpylib as cpl

THIS_DIR = os.path.dirname(os.path.abspath(__file__))
matplotlib.use("Agg")

PLOT_WARNING = "Matplotlib is currently using agg, which is a non-GUI backend, so cannot show the figure."


class TestCellularAutomataFunctions(unittest.TestCase):

    def test_rule0_simple_init(self):
        expected = self._convert_to_numpy_matrix("rule0_simple_init.ca")
        actual = self._create_ca(expected, 0)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule0_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule0_simple_init.ca")
        actual = self._create_ca(expected, 0, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule0_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule0_simple_init.ca")
        actual = self._create_ca(expected, 0, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule0_random_init(self):
        expected = self._convert_to_numpy_matrix("rule0_random_init.ca")
        actual = self._create_ca(expected, 0)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule0_random_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule0_random_init.ca")
        actual = self._create_ca(expected, 0, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule0_random_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule0_random_init.ca")
        actual = self._create_ca(expected, 0, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule30_simple_init(self):
        expected = self._convert_to_numpy_matrix("rule30_simple_init.ca")
        actual = self._create_ca(expected, 30)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule30_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule30_simple_init.ca")
        actual = self._create_ca(expected, 30, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule30_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule30_simple_init.ca")
        actual = self._create_ca(expected, 30, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule30_random_init(self):
        expected = self._convert_to_numpy_matrix("rule30_random_init.ca")
        actual = self._create_ca(expected, 30)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule30_random_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule30_random_init.ca")
        actual = self._create_ca(expected, 30, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule30_random_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule30_random_init.ca")
        actual = self._create_ca(expected, 30, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule126_simple_init(self):
        expected = self._convert_to_numpy_matrix("rule126_simple_init.ca")
        actual = self._create_ca(expected, 126)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule126_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule126_simple_init.ca")
        actual = self._create_ca(expected, 126, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule126_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule126_simple_init.ca")
        actual = self._create_ca(expected, 126, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule126_random_init(self):
        expected = self._convert_to_numpy_matrix("rule126_random_init.ca")
        actual = self._create_ca(expected, 126)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule126_random_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule126_random_init.ca")
        actual = self._create_ca(expected, 126, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule126_random_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule126_random_init.ca")
        actual = self._create_ca(expected, 126, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule225_simple_init(self):
        expected = self._convert_to_numpy_matrix("rule225_simple_init.ca")
        actual = self._create_ca(expected, 225)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule225_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule225_simple_init.ca")
        actual = self._create_ca(expected, 225, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule225_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule225_simple_init.ca")
        actual = self._create_ca(expected, 225, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule225_random_init(self):
        expected = self._convert_to_numpy_matrix("rule225_random_init.ca")
        actual = self._create_ca(expected, 225)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule225_random_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule225_random_init.ca")
        actual = self._create_ca(expected, 225, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule225_random_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule225_random_init.ca")
        actual = self._create_ca(expected, 225, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule255_simple_init(self):
        expected = self._convert_to_numpy_matrix("rule255_simple_init.ca")
        actual = self._create_ca(expected, 255)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule255_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule255_simple_init.ca")
        actual = self._create_ca(expected, 255, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule255_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule255_simple_init.ca")
        actual = self._create_ca(expected, 255, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule255_random_init(self):
        expected = self._convert_to_numpy_matrix("rule255_random_init.ca")
        actual = self._create_ca(expected, 255)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule255_random_init_memoized(self):
        expected = self._convert_to_numpy_matrix("rule255_random_init.ca")
        actual = self._create_ca(expected, 255, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule255_random_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("rule255_random_init.ca")
        actual = self._create_ca(expected, 255, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_rule255_random_init_callable(self):
        expected = self._convert_to_numpy_matrix("rule255_random_init.ca")
        actual = self._create_ca_callable(expected, 255)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_3color_rule777_simple_init(self):
        expected = self._convert_to_numpy_matrix("tot3_rule777_simple_init.ca")
        actual = self._create_totalistic_ca(expected, 3, 777)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_3color_rule777_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("tot3_rule777_simple_init.ca")
        actual = self._create_totalistic_ca(expected, 3, 777, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_3color_rule777_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("tot3_rule777_simple_init.ca")
        actual = self._create_totalistic_ca(expected, 3, 777, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_3color_rule777_random_init(self):
        expected = self._convert_to_numpy_matrix("tot3_rule777_random_init.ca")
        actual = self._create_totalistic_ca(expected, 3, 777)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_3color_rule777_random_init_memoized(self):
        expected = self._convert_to_numpy_matrix("tot3_rule777_random_init.ca")
        actual = self._create_totalistic_ca(expected, 3, 777, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_3color_rule777_random_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("tot3_rule777_random_init.ca")
        actual = self._create_totalistic_ca(expected, 3, 777, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_4color_rule107396_simple_init(self):
        expected = self._convert_to_numpy_matrix("tot4_rule107396_simple_init.ca")
        actual = self._create_totalistic_ca(expected, 4, 107396)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_4color_rule107396_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("tot4_rule107396_simple_init.ca")
        actual = self._create_totalistic_ca(expected, 4, 107396, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_4color_rule107396_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("tot4_rule107396_simple_init.ca")
        actual = self._create_totalistic_ca(expected, 4, 107396, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_4color_rule107396_random_init(self):
        expected = self._convert_to_numpy_matrix("tot4_rule107396_random_init.ca")
        actual = self._create_totalistic_ca(expected, 4, 107396)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_4color_rule107396_random_init_memoized(self):
        expected = self._convert_to_numpy_matrix("tot4_rule107396_random_init.ca")
        actual = self._create_totalistic_ca(expected, 4, 107396, memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_4color_rule107396_random_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("tot4_rule107396_random_init.ca")
        actual = self._create_totalistic_ca(expected, 4, 107396, memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_totalistic_4color_rule107396_random_init_callable(self):
        expected = self._convert_to_numpy_matrix("tot4_rule107396_random_init.ca")
        actual = self._create_totalistic_ca_callable(expected, 4, 107396)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_random_rule_table(self):
        table, _, _ = cpl.random_rule_table(k=2, r=1)
        self.assertTrue(0 <= table['000'] <= 1)
        self.assertTrue(0 <= table['001'] <= 1)
        self.assertTrue(0 <= table['010'] <= 1)
        self.assertTrue(0 <= table['100'] <= 1)
        self.assertTrue(0 <= table['110'] <= 1)
        self.assertTrue(0 <= table['011'] <= 1)
        self.assertTrue(0 <= table['101'] <= 1)
        self.assertTrue(0 <= table['111'] <= 1)

    def test_random_rule_table_lambda1(self):
        table, actual_lambda, quiescent_val = cpl.random_rule_table(k=2, r=1, lambda_val=1.0, quiescent_state=1)
        self.assertEqual(table['000'], 0)
        self.assertEqual(table['001'], 0)
        self.assertEqual(table['010'], 0)
        self.assertEqual(table['100'], 0)
        self.assertEqual(table['110'], 0)
        self.assertEqual(table['011'], 0)
        self.assertEqual(table['101'], 0)
        self.assertEqual(table['111'], 0)
        self.assertEqual(actual_lambda, 1.0)
        self.assertEqual(quiescent_val, 1)

    def test_random_rule_table_lambda0(self):
        table, actual_lambda, quiescent_val = cpl.random_rule_table(k=2, r=1, lambda_val=0.0, quiescent_state=1)
        self.assertEqual(table['000'], 1)
        self.assertEqual(table['001'], 1)
        self.assertEqual(table['010'], 1)
        self.assertEqual(table['100'], 1)
        self.assertEqual(table['110'], 1)
        self.assertEqual(table['011'], 1)
        self.assertEqual(table['101'], 1)
        self.assertEqual(table['111'], 1)
        self.assertEqual(actual_lambda, 0.0)
        self.assertEqual(quiescent_val, 1)

    def test_random_rule_table_strong_quiescence(self):
        table, _, _ = cpl.random_rule_table(k=4, r=1, strong_quiescence=True)
        self.assertEqual(table['000'], 0)
        self.assertEqual(table['111'], 1)
        self.assertEqual(table['222'], 2)
        self.assertEqual(table['333'], 3)

    def test_random_rule_table_isotropic(self):
        table, _, _ = cpl.random_rule_table(k=3, r=1, isotropic=True)
        self.assertTrue(0 <= table['000'] <= 2)
        self.assertTrue(0 <= table['111'] <= 2)
        self.assertTrue(0 <= table['222'] <= 2)
        self.assertTrue(0 <= table['010'] <= 2)
        self.assertTrue(0 <= table['020'] <= 2)
        self.assertTrue(0 <= table['101'] <= 2)
        self.assertTrue(0 <= table['202'] <= 2)
        self.assertTrue(0 <= table['121'] <= 2)
        self.assertTrue(0 <= table['212'] <= 2)
        self.assertEqual(table['001'], table['100'])
        self.assertEqual(table['002'], table['200'])
        self.assertEqual(table['110'], table['011'])
        self.assertEqual(table['220'], table['022'])
        self.assertEqual(table['120'], table['021'])
        self.assertEqual(table['210'], table['012'])
        self.assertEqual(table['211'], table['112'])
        self.assertEqual(table['122'], table['221'])
        self.assertEqual(table['102'], table['201'])

    def test_random_rule_table_illegal_quiescent_state(self):
        with pytest.raises(Exception) as e:
            table, _, _ = cpl.random_rule_table(k=3, r=1, isotropic=True, quiescent_state=4)
        self.assertTrue("quiescent state must be a number in {0,...,k - 1}" in str(e.value))

    def test_table_walk_through_increasing(self):
        table, actual_lambda, quiescent_state = cpl.random_rule_table(k=3, r=1, lambda_val=0.0)
        table, new_lambda = cpl.table_walk_through(table, lambda_val=1.0, k=3, r=1, quiescent_state=quiescent_state)
        self.assertEqual(new_lambda, 1.0)

    def test_table_walk_through_decreasing(self):
        table, actual_lambda, quiescent_state = cpl.random_rule_table(k=3, r=1, lambda_val=1.0)
        table, new_lambda = cpl.table_walk_through(table, lambda_val=0.0, k=3, r=1, quiescent_state=quiescent_state)
        self.assertEqual(new_lambda, 0.0)

    def test_table_walk_through_increasing_strong_quiescence(self):
        table, actual_lambda, quiescent_state = cpl.random_rule_table(k=3, r=1, lambda_val=0.0, strong_quiescence=True)
        table, new_lambda = cpl.table_walk_through(table, lambda_val=1.0, k=3, r=1, quiescent_state=quiescent_state,
                                                   strong_quiescence=True)
        np.testing.assert_almost_equal(new_lambda, 0.96, decimal=2)

    def test_table_walk_through_decreasing_strong_quiescence(self):
        table, actual_lambda, quiescent_state = cpl.random_rule_table(k=3, r=1, lambda_val=1.0, strong_quiescence=True)
        table, new_lambda = cpl.table_walk_through(table, lambda_val=0.0, k=3, r=1, quiescent_state=quiescent_state,
                                                   strong_quiescence=True)
        np.testing.assert_almost_equal(new_lambda, 0.07, decimal=2)

    def test_table_walk_through_increasing_isotropic(self):
        table, actual_lambda, quiescent_state = cpl.random_rule_table(k=3, r=1, lambda_val=0.0, isotropic=True)
        table, new_lambda = cpl.table_walk_through(table, lambda_val=1.0, k=3, r=1, quiescent_state=quiescent_state,
                                                   isotropic=True)
        self.assertEqual(new_lambda, 1.0)

    def test_table_walk_through_decreasing_isotropic(self):
        table, actual_lambda, quiescent_state = cpl.random_rule_table(k=3, r=1, lambda_val=1.0, isotropic=True)
        table, new_lambda = cpl.table_walk_through(table, lambda_val=0.0, k=3, r=1, quiescent_state=quiescent_state,
                                                   isotropic=True)
        self.assertEqual(new_lambda, 0.0)

    def test_table_walk_through_lambda_is_actual_lambda(self):
        table = {'101': 1, '111': 0, '011': 0, '110': 1, '000': 0, '100': 0, '010': 0, '001': 1}
        table, new_lambda = cpl.table_walk_through(table, lambda_val=0.8148148148148148, k=3, r=1, quiescent_state=0,
                                                   isotropic=True)
        self.assertEqual(new_lambda, 0.8148148148148148)

    def test_table_rule(self):
        r = cpl.table_rule([1, 1, 0], {'101': 1, '111': 0, '011': 0, '110': 1, '000': 0, '100': 0, '010': 0, '001': 1})
        self.assertEqual(r, 1)

        with pytest.raises(Exception) as e:
            cpl.table_rule([0, 0, 1], {'101': 1, '111': 0, '011': 0, '110': 1, '000': 0, '100': 0, '010': 0})
        self.assertTrue("could not find state '001' in table" in str(e))

    def test_init_simple_1(self):
        arr = cpl.init_simple(1)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 1)
        self.assertEqual(arr[0][0], 1)

    def test_init_simple_1_val2(self):
        arr = cpl.init_simple(1, val=2)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 1)
        self.assertEqual(arr[0][0], 2)

    def test_init_simple_3(self):
        arr = cpl.init_simple(3)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertEqual(arr[0][0], 0)
        self.assertEqual(arr[0][1], 1)
        self.assertEqual(arr[0][2], 0)

    def test_init_random_3(self):
        arr = cpl.init_random(3, empty_value=9)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertTrue(0 <= arr[0][0] <= 1)
        self.assertTrue(0 <= arr[0][1] <= 1)
        self.assertTrue(0 <= arr[0][2] <= 1)

    def test_init_random_3_k3(self):
        arr = cpl.init_random(3, k=3, empty_value=9)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertTrue(0 <= arr[0][0] <= 2)
        self.assertTrue(0 <= arr[0][1] <= 2)
        self.assertTrue(0 <= arr[0][2] <= 2)

    def test_init_random_3_k3_n1(self):
        arr = cpl.init_random(3, k=3, n_randomized=1, empty_value=9)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertEqual(arr[0][0], 9)
        self.assertTrue(0 <= arr[0][1] <= 2)
        self.assertEqual(arr[0][2], 9)

    def test_init_random_3_k3_n0(self):
        arr = cpl.init_random(3, k=3, n_randomized=0, empty_value=9)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertEqual(arr[0][0], 9)
        self.assertEqual(arr[0][1], 9)
        self.assertEqual(arr[0][2], 9)

    def test_init_random_3_k3_n3(self):
        arr = cpl.init_random(3, k=3, n_randomized=3, empty_value=9)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertTrue(0 <= arr[0][0] <= 2)
        self.assertTrue(0 <= arr[0][1] <= 2)
        self.assertTrue(0 <= arr[0][2] <= 2)

    def test_init_random_3_k3_n2(self):
        arr = cpl.init_random(3, k=3, n_randomized=2, empty_value=9)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertTrue(0 <= arr[0][0] <= 2)
        self.assertTrue(0 <= arr[0][1] <= 2)
        self.assertEqual(arr[0][2], 9)

    def test_init_random_1_k3_n1(self):
        arr = cpl.init_random(1, k=3, n_randomized=1, empty_value=9)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 1)
        self.assertTrue(0 <= arr[0][0] <= 2)

    def test_init_random_1_k3_n0(self):
        arr = cpl.init_random(1, k=3, n_randomized=0, empty_value=9)
        self.assertEqual(len(arr), 1)
        arr = arr[0]
        self.assertEqual(len(arr), 1)
        self.assertEqual(arr[0], 9)

    def test_init_random_illegal_number_of_sites(self):
        with pytest.raises(Exception) as e:
            cpl.init_random(5, n_randomized=6)
        self.assertTrue("the number of randomized sites, if specified, must be >= 0 and <= size" in str(e.value))

    def test_shannon_entropy(self):
        entropy = cpl.shannon_entropy('1111111')
        self.assertEqual(entropy, 0)
        entropy = cpl.shannon_entropy('0000000')
        self.assertEqual(entropy, 0)
        entropy = cpl.shannon_entropy('01010101')
        self.assertEqual(entropy, 1.0)
        entropy = cpl.shannon_entropy('00010001')
        np.testing.assert_almost_equal(entropy, 0.8113, decimal=4)
        entropy = cpl.shannon_entropy('1234')
        self.assertEqual(entropy, 2.0)

    def test_average_cell_entropy(self):
        cellular_automaton = self._convert_to_numpy_matrix("rule30_random_init.ca")
        avg_cell_entropy = cpl.average_cell_entropy(cellular_automaton)
        np.testing.assert_almost_equal(avg_cell_entropy, 0.9946, decimal=4)

    def test_joint_shannon_entropy(self):
        joint_entropy = cpl.joint_shannon_entropy('0010101', '3232223')
        np.testing.assert_almost_equal(joint_entropy, 1.842, decimal=3)

    def test_mutual_information(self):
        mutual_information = cpl.mutual_information('0010101', '3232223')
        np.testing.assert_almost_equal(mutual_information, 0.1281, decimal=4)
        mutual_information = cpl.mutual_information('0010101', '1101010')
        np.testing.assert_almost_equal(mutual_information, 0.9852, decimal=4)
        mutual_information = cpl.mutual_information('0010101', '0010101')
        np.testing.assert_almost_equal(mutual_information, 0.9852, decimal=4)
        mutual_information = cpl.mutual_information('0010101', '0001001')
        np.testing.assert_almost_equal(mutual_information, 0.0060, decimal=4)

    def test_average_mutual_information(self):
        cellular_automaton = self._convert_to_numpy_matrix("rule30_random_init.ca")
        avg_mutual_information = cpl.average_mutual_information(cellular_automaton)
        np.testing.assert_almost_equal(avg_mutual_information, 0.0047, decimal=4)
        avg_mutual_information = cpl.average_mutual_information(cellular_automaton, temporal_distance=2)
        np.testing.assert_almost_equal(avg_mutual_information, 0.0050, decimal=4)
        avg_mutual_information = cpl.average_mutual_information(cellular_automaton, temporal_distance=3)
        np.testing.assert_almost_equal(avg_mutual_information, 0.0051, decimal=4)

    def test_average_mutual_information_illegal_temporal_distance(self):
        cellular_automaton = np.array([[1, 0, 1], [0, 1, 1]])
        with pytest.raises(Exception) as e:
            cpl.average_mutual_information(cellular_automaton, temporal_distance=4)
        self.assertTrue("the temporal distance must be greater than 0 and less than the number of time steps" in str(e.value))

    def test_evolve_apply_rule_1_step(self):
        cellular_automaton = np.array([[1, 2, 3, 4, 5]])
        cellular_automaton = cpl.evolve(cellular_automaton, timesteps=1, apply_rule=lambda n, c, t: 1)
        np.testing.assert_equal(cellular_automaton.tolist(), [[1, 2, 3, 4, 5]])

    def test_evolve_apply_rule_3_steps(self):
        cellular_automaton = np.array([[1, 2, 3, 4, 5]])
        neighbourhoods = []
        cell_identities = []
        timesteps = []
        def apply_rule(n, c, t):
            neighbourhoods.append(n.tolist())
            cell_identities.append(c)
            timesteps.append(t)
            return n[1]
        cpl.evolve(cellular_automaton, timesteps=3, apply_rule=apply_rule)
        np.testing.assert_equal(neighbourhoods, [[5, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 1],
                                                 [5, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 1]])
        np.testing.assert_equal(cell_identities, [0, 1, 2, 3, 4, 0, 1, 2, 3, 4])
        np.testing.assert_equal(timesteps, [1, 1, 1, 1, 1, 2, 2, 2, 2, 2])

    def test_rule150R_simple_init(self):
        expected = self._convert_to_numpy_matrix("rule150R_simple_init.ca")
        actual = self._create_reversible_ca(expected, 150)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_dtype(self):
        cellular_automaton = cpl.init_simple(11, dtype=np.float32)
        cellular_automaton = cpl.evolve(cellular_automaton, timesteps=6,
                                        apply_rule=lambda n, c, t: sum(n) / len(n))
        np.testing.assert_almost_equal(cellular_automaton.tolist(), [
            [0.0,   0.0,   0.0,   0.0,   0.0,   1.0,   0.0,   0.0,   0.0,   0.0,    0.0],
            [0.0,   0.0,   0.0,   0.0,   0.333, 0.333, 0.333, 0.0,   0.0,   0.0,    0.0],
            [0.0,   0.0,   0.0,   0.111, 0.222, 0.333, 0.222, 0.111, 0.0,   0.0,    0.0],
            [0.0,   0.0,   0.037, 0.111, 0.222, 0.259, 0.222, 0.111, 0.037, 0.0,    0.0],
            [0.0,   0.012, 0.049, 0.123, 0.198, 0.235, 0.198, 0.123, 0.049, 0.0123, 0.0],
            [0.004, 0.021, 0.062, 0.123, 0.185, 0.210, 0.185, 0.123, 0.062, 0.021,  0.004]], decimal=3)

    def test_sequential_left_to_right(self):
        expected = self._convert_to_numpy_matrix("rule60_sequential_simple_init.ca")
        cellular_automaton = cpl.init_simple(21)
        r = cpl.AsynchronousRule(apply_rule=lambda n, c, t: cpl.nks_rule(n, 60), update_order=range(1, 20))
        cellular_automaton = cpl.evolve(cellular_automaton, timesteps=19*20,
                                        apply_rule=r)
        np.testing.assert_equal(expected.tolist(), cellular_automaton[::19].tolist())

    def test_sequential_random(self):
        expected = self._convert_to_numpy_matrix("rule90_sequential_simple_init.ca")
        cellular_automaton = cpl.init_simple(21)
        update_order = [19, 11, 4, 9, 6, 16, 10, 2, 17, 1, 12, 15, 5, 3, 8, 18, 7, 13, 14]
        r = cpl.AsynchronousRule(apply_rule=lambda n, c, t: cpl.nks_rule(n, 90), update_order=update_order)
        cellular_automaton = cpl.evolve(cellular_automaton, timesteps=19*20,
                                        apply_rule=r)
        np.testing.assert_equal(expected.tolist(), cellular_automaton[::19].tolist())

    def test_dynamic_timesteps(self):
        initial = np.array([[17]], dtype=np.int)

        def activity_rule(n, c, t):
            n = n[1]
            if n % 2 == 0:
                # number is even
                return n / 2
            else:
                return 3 * n + 1

        ca = cpl.evolve(initial, apply_rule=activity_rule,
                        timesteps=lambda ca, t: True if ca[-1][0] != 1 else False)

        self.assertEqual([17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], [i[0] for i in ca])

    def test_dynamic_timesteps_memoized(self):
        initial = np.array([[17]], dtype=np.int)

        def activity_rule(n, c, t):
            n = n[1]
            if n % 2 == 0:
                # number is even
                return n / 2
            else:
                return 3 * n + 1

        ca = cpl.evolve(initial, apply_rule=activity_rule,
                        timesteps=lambda ca, t: True if ca[-1][0] != 1 else False, memoize=True)

        self.assertEqual([17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], [i[0] for i in ca])

    def test_dynamic_timesteps_memoized_recursive(self):
        initial = np.array([[17]], dtype=np.int)

        def activity_rule(n, c, t):
            n = n[1]
            if n % 2 == 0:
                # number is even
                return n / 2
            else:
                return 3 * n + 1

        ca = cpl.evolve(initial, apply_rule=activity_rule,
                        timesteps=lambda ca, t: True if ca[-1][0] != 1 else False, memoize="recursive")

        self.assertEqual([17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], [i[0] for i in ca])

    def test_prior_history(self):
        initial = np.array([[17], [18], [19]], dtype=np.int)

        def activity_rule(n, c, t):
            return n[1] + 1

        ca = cpl.evolve(initial, apply_rule=activity_rule, timesteps=2)

        self.assertEqual([[17], [18], [19], [20]], ca.tolist())

    def test_init_random_dtype(self):
        arr = cpl.init_random(3, dtype=np.float32)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertTrue(0.0 <= arr[0][0] < 1.0)
        self.assertTrue(0.0 <= arr[0][1] < 1.0)
        self.assertTrue(0.0 <= arr[0][2] < 1.0)

    def test_evolve_block(self):
        expected = self._convert_to_numpy_matrix("block_1d.ca")
        initial_conditions = np.array([[0] * 13 + [1] * 2 + [0] * 201])

        def block_rule(n, t):
            if n == (1, 1): return 1, 1
            elif n == (1, 0): return 1, 0
            elif n == (0, 1): return 0, 0
            elif n == (0, 0): return 0, 1

        actual = cpl.evolve_block(initial_conditions, block_size=2, timesteps=200, apply_rule=block_rule)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def _convert_to_numpy_matrix(self, filename):
        with open(os.path.join(THIS_DIR, 'resources', filename), 'r') as content_file:
            content = content_file.read()
        return np.array(ast.literal_eval(content.replace("{", "[").replace("}", "]")), dtype=np.int32)

    def _create_ca(self, expected, rule, memoize=False):
        rows, _ = expected.shape
        cellular_automaton = expected[0].reshape(1, -1)
        return cpl.evolve(cellular_automaton, timesteps=rows,
                          apply_rule=lambda n, c, t: cpl.nks_rule(n, rule), memoize=memoize)

    def _create_ca_callable(self, expected, rule):
        rows, _ = expected.shape
        cellular_automaton = expected[0].reshape(1, -1)
        return cpl.evolve(cellular_automaton, timesteps=rows, apply_rule=cpl.NKSRule(rule))

    def _create_totalistic_ca(self, expected, k, rule, memoize=False):
        rows, _ = expected.shape
        cellular_automaton = expected[0].reshape(1, -1)
        return cpl.evolve(cellular_automaton, timesteps=rows,
                          apply_rule=lambda n, c, t: cpl.totalistic_rule(n, k, rule), memoize=memoize)

    def _create_totalistic_ca_callable(self, expected, k, rule):
        rows, _ = expected.shape
        cellular_automaton = expected[0].reshape(1, -1)
        return cpl.evolve(cellular_automaton, timesteps=rows, apply_rule=cpl.TotalisticRule(k, rule))

    def _create_reversible_ca(self, expected, rule):
        rows, _ = expected.shape
        cellular_automaton = expected[0].reshape(1, -1)
        r = cpl.ReversibleRule(cellular_automaton.tolist()[0], rule)
        return cpl.evolve(cellular_automaton, timesteps=rows, apply_rule=r)

    def test_binary_rule(self):
        rule_number = 6667021275756174439087127638698866559
        radius = 3
        timesteps = 12
        init = np.array([[1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1]])

        actual = cpl.evolve(init, timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number), r=radius)

        expected = np.array([[1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1],
                             [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1],
                             [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                             [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0],
                             [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
                             [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0],
                             [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1],
                             [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0],
                             [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
                             [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                             [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                             [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_memoized(self):
        rule_number = 6667021275756174439087127638698866559
        radius = 3
        timesteps = 12
        init = np.array([[1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1]])

        actual = cpl.evolve(init, timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number),
                            r=radius, memoize=True)

        expected = np.array([[1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1],
                             [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1],
                             [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                             [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0],
                             [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
                             [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0],
                             [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1],
                             [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0],
                             [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
                             [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                             [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                             [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_memoized_recursive(self):
        rule_number = 6667021275756174439087127638698866559
        radius = 3
        timesteps = 12
        init = np.array([[1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1]])

        actual = cpl.evolve(init, timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number),
                            r=radius, memoize="recursive")

        expected = np.array([[1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1],
                             [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1],
                             [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                             [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0],
                             [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
                             [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0],
                             [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1],
                             [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0],
                             [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
                             [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                             [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                             [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_callable(self):
        rule_number = 6667021275756174439087127638698866559
        radius = 3
        timesteps = 12
        init = np.array([[1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1]])

        actual = cpl.evolve(init, timesteps=timesteps,
                            apply_rule=cpl.BinaryRule(rule_number), r=radius)

        expected = np.array([[1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1],
                             [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1],
                             [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                             [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0],
                             [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
                             [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0],
                             [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1],
                             [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0],
                             [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1],
                             [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                             [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                             [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_powers_of_two_nks(self):
        rule_number = 30
        radius = 1
        size = 149
        timesteps = 149

        expected = cpl.evolve(cpl.init_simple(size=size), timesteps=timesteps,
                              apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number, scheme="nks"), r=radius)

        powers_of_two = 2 ** np.arange(radius * 2 + 1)[::-1]
        rule = list(map(int, bin(rule_number)[2:]))
        rule_bin_array = np.pad(rule, ((2 ** (radius * 2 + 1)) - len(rule), 0), 'constant').tolist()
        actual = cpl.evolve(cpl.init_simple(size=size), timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_bin_array, scheme="nks",
                                                                       powers_of_two=powers_of_two),
                            r=radius)

        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_powers_of_two_nks_memoized(self):
        rule_number = 30
        radius = 1
        size = 149
        timesteps = 149

        expected = cpl.evolve(cpl.init_simple(size=size), timesteps=timesteps,
                              apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number, scheme="nks"),
                              r=radius, memoize=True)

        powers_of_two = 2 ** np.arange(radius * 2 + 1)[::-1]
        rule = list(map(int, bin(rule_number)[2:]))
        rule_bin_array = np.pad(rule, ((2 ** (radius * 2 + 1)) - len(rule), 0), 'constant').tolist()
        actual = cpl.evolve(cpl.init_simple(size=size), timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_bin_array, scheme="nks",
                                                                       powers_of_two=powers_of_two),
                            r=radius, memoize=True)

        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_powers_of_two_nks_memoize_recursive(self):
        rule_number = 30
        radius = 1
        size = 149
        timesteps = 149

        expected = cpl.evolve(cpl.init_simple(size=size), timesteps=timesteps,
                              apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number, scheme="nks"),
                              r=radius, memoize=True)

        powers_of_two = 2 ** np.arange(radius * 2 + 1)[::-1]
        rule = list(map(int, bin(rule_number)[2:]))
        rule_bin_array = np.pad(rule, ((2 ** (radius * 2 + 1)) - len(rule), 0), 'constant').tolist()
        actual = cpl.evolve(cpl.init_simple(size=size), timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_bin_array, scheme="nks",
                                                                       powers_of_two=powers_of_two),
                            r=radius, memoize="recursive")

        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_powers_of_two_default(self):
        rule_number = 6667021275756174439087127638698866559
        radius = 3
        timesteps = 49
        init = np.array([[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                          1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1]])

        expected = cpl.evolve(init, timesteps=timesteps,
                              apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number), r=radius)

        powers_of_two = 2 ** np.arange(radius * 2 + 1)[::-1]
        rule = list(map(int, bin(rule_number)[2:]))
        rule_bin_array = np.pad(rule, ((2 ** (radius * 2 + 1)) - len(rule), 0), 'constant')
        actual = cpl.evolve(init, timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_bin_array, powers_of_two=powers_of_two),
                            r=radius)

        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_powers_of_two_default_memoized(self):
        rule_number = 6667021275756174439087127638698866559
        radius = 3
        timesteps = 49
        init = np.array([[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                          1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1]])

        expected = cpl.evolve(init, timesteps=timesteps,
                              apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number),
                              r=radius, memoize=True)

        powers_of_two = 2 ** np.arange(radius * 2 + 1)[::-1]
        rule = list(map(int, bin(rule_number)[2:]))
        rule_bin_array = np.pad(rule, ((2 ** (radius * 2 + 1)) - len(rule), 0), 'constant')
        actual = cpl.evolve(init, timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_bin_array, powers_of_two=powers_of_two),
                            r=radius, memoize=True)

        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_binary_rule_powers_of_two_default_memoize_recursive(self):
        rule_number = 6667021275756174439087127638698866559
        radius = 3
        timesteps = 49
        init = np.array([[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0,
                          1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1]])

        expected = cpl.evolve(init, timesteps=timesteps,
                              apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_number),
                              r=radius, memoize=True)

        powers_of_two = 2 ** np.arange(radius * 2 + 1)[::-1]
        rule = list(map(int, bin(rule_number)[2:]))
        rule_bin_array = np.pad(rule, ((2 ** (radius * 2 + 1)) - len(rule), 0), 'constant')
        actual = cpl.evolve(init, timesteps=timesteps,
                            apply_rule=lambda n, c, t: cpl.binary_rule(n, rule_bin_array, powers_of_two=powers_of_two),
                            r=radius, memoize="recursive")

        np.testing.assert_equal(expected.tolist(), actual.tolist())

    @pytest.mark.filterwarnings("ignore:{}".format(PLOT_WARNING))
    def test_plot(self):
        # this test ensures that the following code can run successfully without issue
        cpl.plot([[1, 0, 1], [1, 1, 1]], title="some test")

    @pytest.mark.filterwarnings("ignore:{}".format(PLOT_WARNING))
    def test_plot_multiple(self):
        # this test ensures that the following code can run successfully without issue
        cpl.plot_multiple([
            [[1, 0, 1], [1, 1, 1]],
            [[0, 1, 1], [1, 1, 1]]
        ], titles=["test 1", "test 2"])

    def test_bits_to_int(self):
        self.assertEqual(9, cpl.bits_to_int([1, 0, 0, 1]))

    def test_int_to_bits(self):
        np.testing.assert_equal([1, 0, 0, 1], cpl.int_to_bits(9, 4))


if __name__ == "__main__":
    unittest.main()


 

========== FILE: tests/test_cellpylib2d.py ==========

import unittest
import pytest
import matplotlib

import numpy as np
import os

import cellpylib as cpl
import warnings

THIS_DIR = os.path.dirname(os.path.abspath(__file__))
matplotlib.use("Agg")


class TestCellularAutomataFunctions2D(unittest.TestCase):

    def test_init_simple2d_1x1(self):
        arr = cpl.init_simple2d(rows=1, cols=1)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 1)
        self.assertEqual(len(arr[0][0]), 1)
        self.assertEqual(arr[0][0][0], 1)

    def test_init_simple2d_1x1_val2(self):
        arr = cpl.init_simple2d(rows=1, cols=1, val=2)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 1)
        self.assertEqual(len(arr[0][0]), 1)
        self.assertEqual(arr[0][0][0], 2)

    def test_init_simple2d_2x2(self):
        arr = cpl.init_simple2d(rows=2, cols=2)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 2)
        self.assertEqual(len(arr[0][0]), 2)
        self.assertEqual(len(arr[0][1]), 2)
        self.assertEqual(arr[0][0].tolist(), [0, 0])
        self.assertEqual(arr[0][1].tolist(), [0, 1])

    def test_init_simple2d_3x3(self):
        arr = cpl.init_simple2d(rows=3, cols=3)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertEqual(len(arr[0][0]), 3)
        self.assertEqual(len(arr[0][1]), 3)
        self.assertEqual(len(arr[0][2]), 3)
        self.assertEqual(arr[0][0].tolist(), [0, 0, 0])
        self.assertEqual(arr[0][1].tolist(), [0, 1, 0])
        self.assertEqual(arr[0][2].tolist(), [0, 0, 0])

    def test_init_simple2d_2x3(self):
        arr = cpl.init_simple2d(rows=2, cols=3)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 2)
        self.assertEqual(len(arr[0][0]), 3)
        self.assertEqual(len(arr[0][1]), 3)
        self.assertEqual(arr[0][0].tolist(), [0, 0, 0])
        self.assertEqual(arr[0][1].tolist(), [0, 1, 0])

    def test_init_simple2d_coords(self):
        arr = cpl.init_simple2d(rows=3, cols=3, coords=(2, 2))
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertEqual(len(arr[0][0]), 3)
        self.assertEqual(len(arr[0][1]), 3)
        self.assertEqual(len(arr[0][2]), 3)
        self.assertEqual(arr[0][0].tolist(), [0, 0, 0])
        self.assertEqual(arr[0][1].tolist(), [0, 0, 0])
        self.assertEqual(arr[0][2].tolist(), [0, 0, 1])

    def test_init_simple2d_coords_invalid_type(self):
        with pytest.raises(Exception):
            cpl.init_simple2d(rows=3, cols=3, coords="a")

    def test_init_simple2d_coords_invalid_length(self):
        with pytest.raises(Exception):
            cpl.init_simple2d(rows=3, cols=3, coords=(0, 1, 2))

    def test_init_random2d_1x1(self):
        arr = cpl.init_random2d(1, 1)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 1)
        self.assertEqual(len(arr[0][0]), 1)
        self.assertTrue(0 <= arr[0][0][0] <= 1)

    def test_init_random2d_1x1_k2(self):
        arr = cpl.init_random2d(rows=1, cols=1, k=2)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 1)
        self.assertEqual(len(arr[0][0]), 1)
        self.assertTrue(0 <= arr[0][0][0] <= 2)

    def test_init_random2d_2x2(self):
        arr = cpl.init_random2d(rows=2, cols=2)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 2)
        self.assertEqual(len(arr[0][0]), 2)
        self.assertEqual(len(arr[0][1]), 2)
        self.assertTrue(0 <= arr[0][0][0] <= 1)
        self.assertTrue(0 <= arr[0][0][1] <= 1)
        self.assertTrue(0 <= arr[0][1][0] <= 1)
        self.assertTrue(0 <= arr[0][1][1] <= 1)

    def test_init_random2d_3x3_k2(self):
        arr = cpl.init_random2d(rows=3, cols=3, k=2)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 3)
        self.assertEqual(len(arr[0][0]), 3)
        self.assertEqual(len(arr[0][1]), 3)
        self.assertEqual(len(arr[0][2]), 3)
        self.assertTrue(0 <= arr[0][0][0] <= 2)
        self.assertTrue(0 <= arr[0][0][1] <= 2)
        self.assertTrue(0 <= arr[0][0][2] <= 2)
        self.assertTrue(0 <= arr[0][1][0] <= 2)
        self.assertTrue(0 <= arr[0][1][1] <= 2)
        self.assertTrue(0 <= arr[0][1][2] <= 2)
        self.assertTrue(0 <= arr[0][2][0] <= 2)
        self.assertTrue(0 <= arr[0][2][1] <= 2)
        self.assertTrue(0 <= arr[0][2][2] <= 2)

    def test_init_random2d_2x3(self):
        arr = cpl.init_random2d(rows=2, cols=3)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 2)
        self.assertEqual(len(arr[0][0]), 3)
        self.assertEqual(len(arr[0][1]), 3)
        self.assertTrue(0 <= arr[0][0][0] <= 1)
        self.assertTrue(0 <= arr[0][0][1] <= 1)
        self.assertTrue(0 <= arr[0][0][2] <= 1)
        self.assertTrue(0 <= arr[0][1][0] <= 1)
        self.assertTrue(0 <= arr[0][1][1] <= 1)
        self.assertTrue(0 <= arr[0][1][2] <= 1)

    def test_init_random2d_dtype(self):
        arr = cpl.init_random2d(rows=2, cols=2, dtype=np.float32)
        self.assertEqual(len(arr), 1)
        self.assertEqual(len(arr[0]), 2)
        self.assertEqual(len(arr[0][0]), 2)
        self.assertEqual(len(arr[0][1]), 2)
        self.assertTrue(0.0 <= arr[0][0][0] < 1.0)
        self.assertTrue(0.0 <= arr[0][0][1] < 1.0)
        self.assertTrue(0.0 <= arr[0][1][0] < 1.0)
        self.assertTrue(0.0 <= arr[0][1][1] < 1.0)

    def test_tot_rule126_2d_n9_simple_init(self):
        expected = self._convert_to_numpy_matrix("tot_rule126_2d_n9_simple_init.ca")
        actual = self._create_ca(expected, 126, 'Moore')
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_tot_rule126_2d_n9_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("tot_rule126_2d_n9_simple_init.ca")
        actual = self._create_ca(expected, 126, 'Moore', memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_tot_rule126_2d_n9_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("tot_rule126_2d_n9_simple_init.ca")
        actual = self._create_ca(expected, 126, 'Moore', memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_tot_rule26_2d_n5_simple_init(self):
        expected = self._convert_to_numpy_matrix("tot_rule26_2d_n5_simple_init.ca")
        actual = self._create_ca(expected, 26, 'von Neumann')
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_tot_rule26_2d_n5_simple_init_memoized(self):
        expected = self._convert_to_numpy_matrix("tot_rule26_2d_n5_simple_init.ca")
        actual = self._create_ca(expected, 26, 'von Neumann', memoize=True)
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_tot_rule26_2d_n5_simple_init_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("tot_rule26_2d_n5_simple_init.ca")
        actual = self._create_ca(expected, 26, 'von Neumann', memoize="recursive")
        np.testing.assert_equal(expected.tolist(), actual.tolist())

    def test_sequential_rule_2d_update_order(self):
        cellular_automaton = cpl.init_simple2d(3, 3)
        r = cpl.AsynchronousRule(apply_rule=lambda n, c, t: cpl.totalistic_rule(n, k=2, rule=126),
                                 update_order=[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)])
        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=18, neighbourhood='Moore', apply_rule=r)
        expected = [[[0, 0, 0], [0, 1, 0], [0, 0, 0]], [[1, 0, 0], [0, 1, 0], [0, 0, 0]],
                    [[1, 1, 0], [0, 1, 0], [0, 0, 0]], [[1, 1, 1], [0, 1, 0], [0, 0, 0]],
                    [[1, 1, 1], [1, 1, 0], [0, 0, 0]], [[1, 1, 1], [1, 1, 0], [0, 0, 0]],
                    [[1, 1, 1], [1, 1, 1], [0, 0, 0]], [[1, 1, 1], [1, 1, 1], [1, 0, 0]],
                    [[1, 1, 1], [1, 1, 1], [1, 0, 0]], [[1, 1, 1], [1, 1, 1], [1, 0, 0]],
                    [[0, 1, 1], [1, 1, 1], [1, 0, 0]], [[0, 1, 1], [1, 1, 1], [1, 0, 0]],
                    [[0, 1, 1], [1, 1, 1], [1, 0, 0]], [[0, 1, 1], [1, 1, 1], [1, 0, 0]],
                    [[0, 1, 1], [1, 1, 1], [1, 0, 0]], [[0, 1, 1], [1, 1, 1], [1, 0, 0]],
                    [[0, 1, 1], [1, 1, 1], [1, 0, 0]], [[0, 1, 1], [1, 1, 1], [1, 1, 0]]]
        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_sequential_rule_2d_num_cells(self):
        np.random.seed(0)
        cellular_automaton = cpl.init_simple2d(3, 3)
        r = cpl.AsynchronousRule(apply_rule=lambda n, c, t: cpl.totalistic_rule(n, k=2, rule=126), num_cells=(3, 3))
        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=18, neighbourhood='Moore', apply_rule=r)
        expected = [[[0, 0, 0], [0, 1, 0], [0, 0, 0]], [[0, 0, 0], [0, 1, 0], [0, 1, 0]],
                    [[0, 0, 1], [0, 1, 0], [0, 1, 0]], [[0, 1, 1], [0, 1, 0], [0, 1, 0]],
                    [[0, 1, 1], [0, 1, 0], [0, 1, 0]], [[0, 1, 1], [0, 1, 0], [0, 1, 1]],
                    [[0, 1, 1], [0, 1, 0], [1, 1, 1]], [[0, 1, 1], [1, 1, 0], [1, 1, 1]],
                    [[0, 1, 1], [1, 1, 0], [1, 1, 1]], [[0, 1, 1], [1, 1, 0], [1, 1, 1]],
                    [[0, 1, 1], [1, 1, 0], [1, 0, 1]], [[0, 1, 1], [1, 1, 0], [1, 0, 1]],
                    [[0, 1, 1], [1, 1, 0], [1, 0, 1]], [[0, 1, 1], [1, 1, 0], [1, 0, 1]],
                    [[0, 1, 1], [1, 1, 0], [1, 0, 1]], [[0, 1, 1], [1, 1, 0], [1, 0, 1]],
                    [[0, 1, 1], [1, 1, 0], [1, 0, 1]], [[1, 1, 1], [1, 1, 0], [1, 0, 1]]]
        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_game_of_life_rule(self):
        expected = self._convert_to_numpy_matrix("game_of_life.ca").reshape(60, 60, 60)

        # Glider
        cellular_automaton = cpl.init_simple2d(60, 60)
        cellular_automaton[:, [28, 29, 30, 30], [30, 31, 29, 31]] = 1
        # Blinker
        cellular_automaton[:, [40, 40, 40], [15, 16, 17]] = 1
        # Light Weight Space Ship (LWSS)
        cellular_automaton[:, [18, 18, 19, 20, 21, 21, 21, 21, 20], [45, 48, 44, 44, 44, 45, 46, 47, 48]] = 1

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=60, neighbourhood='Moore',
                                          apply_rule=cpl.game_of_life_rule)

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_game_of_life_rule_memoized(self):
        expected = self._convert_to_numpy_matrix("game_of_life.ca").reshape(60, 60, 60)

        # Glider
        cellular_automaton = cpl.init_simple2d(60, 60)
        cellular_automaton[:, [28, 29, 30, 30], [30, 31, 29, 31]] = 1
        # Blinker
        cellular_automaton[:, [40, 40, 40], [15, 16, 17]] = 1
        # Light Weight Space Ship (LWSS)
        cellular_automaton[:, [18, 18, 19, 20, 21, 21, 21, 21, 20], [45, 48, 44, 44, 44, 45, 46, 47, 48]] = 1

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=60, neighbourhood='Moore',
                                          apply_rule=cpl.game_of_life_rule, memoize=True)

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_game_of_life_rule_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("game_of_life.ca").reshape(60, 60, 60)

        # Glider
        cellular_automaton = cpl.init_simple2d(60, 60)
        cellular_automaton[:, [28, 29, 30, 30], [30, 31, 29, 31]] = 1
        # Blinker
        cellular_automaton[:, [40, 40, 40], [15, 16, 17]] = 1
        # Light Weight Space Ship (LWSS)
        cellular_automaton[:, [18, 18, 19, 20, 21, 21, 21, 21, 20], [45, 48, 44, 44, 44, 45, 46, 47, 48]] = 1

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=60, neighbourhood='Moore',
                                          apply_rule=cpl.game_of_life_rule, memoize="recursive")

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_langtons_loop(self):
        expected = self._convert_to_numpy_matrix("langtons_loop.ca")

        langtons_loop = cpl.LangtonsLoop()

        cellular_automaton = langtons_loop.init_loops(1, (75, 75), [40], [25])

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=langtons_loop)

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_langtons_loop_memoized(self):
        expected = self._convert_to_numpy_matrix("langtons_loop.ca")

        langtons_loop = cpl.LangtonsLoop()

        cellular_automaton = langtons_loop.init_loops(1, (75, 75), [40], [25])

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=langtons_loop, memoize=True)

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_langtons_loop_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("langtons_loop.ca")

        langtons_loop = cpl.LangtonsLoop()

        cellular_automaton = langtons_loop.init_loops(1, (75, 75), [40], [25])

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=langtons_loop, memoize="recursive")

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_sdsr_loop(self):
        expected = self._convert_to_numpy_matrix("sdsr_loop.ca")

        sdsr_loop = cpl.SDSRLoop()

        cellular_automaton = sdsr_loop.init_loops(1, (75, 75), [40], [25])

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=sdsr_loop)

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_sdsr_loop_memoized(self):
        expected = self._convert_to_numpy_matrix("sdsr_loop.ca")

        sdsr_loop = cpl.SDSRLoop()

        cellular_automaton = sdsr_loop.init_loops(1, (75, 75), [40], [25])

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=sdsr_loop, memoize=True)

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_sdsr_loop_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("sdsr_loop.ca")

        sdsr_loop = cpl.SDSRLoop()

        cellular_automaton = sdsr_loop.init_loops(1, (75, 75), [40], [25])

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=sdsr_loop, memoize="recursive")

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_evoloop(self):
        expected = self._convert_to_numpy_matrix("evoloop.ca")

        evoloop = cpl.Evoloop()

        cellular_automaton = evoloop.init_species13_loop((75, 75), 40, 15)

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=evoloop)

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_evoloop_memoized(self):
        expected = self._convert_to_numpy_matrix("evoloop.ca")

        evoloop = cpl.Evoloop()

        cellular_automaton = evoloop.init_species13_loop((75, 75), 40, 15)

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=evoloop, memoize=True)

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_evoloop_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("evoloop.ca")

        evoloop = cpl.Evoloop()

        cellular_automaton = evoloop.init_species13_loop((75, 75), 40, 15)

        cellular_automaton = cpl.evolve2d(cellular_automaton, timesteps=10,
                                          apply_rule=evoloop, memoize="recursive")

        np.testing.assert_equal(expected, cellular_automaton.tolist())

    def test_block_ca(self):
        expected = self._convert_to_numpy_matrix("block_2d.ca")

        initial_conditions = np.array([[
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ]])

        def block2d_rule(n, t):
            n = tuple(tuple(i) for i in n)
            base_rules = {
                ((0, 0), (0, 0)): ((0, 0), (0, 0)),
                ((0, 0), (0, 2)): ((2, 0), (0, 0)),
                ((2, 0), (0, 0)): ((0, 0), (0, 2)),
                ((0, 0), (2, 0)): ((0, 2), (0, 0)),
                ((0, 2), (0, 0)): ((0, 0), (2, 0)),
                ((0, 0), (2, 2)): ((2, 2), (0, 0)),
                ((2, 2), (0, 0)): ((0, 0), (2, 2)),
                ((0, 2), (0, 2)): ((2, 0), (2, 0)),
                ((2, 0), (2, 0)): ((0, 2), (0, 2)),
                ((0, 2), (2, 0)): ((2, 0), (0, 2)),
                ((2, 0), (0, 2)): ((0, 2), (2, 0)),
                ((0, 2), (2, 2)): ((2, 2), (2, 0)),
                ((2, 2), (2, 0)): ((0, 2), (2, 2)),
                ((2, 0), (2, 2)): ((2, 2), (0, 2)),
                ((2, 2), (0, 2)): ((2, 0), (2, 2)),
                ((2, 2), (2, 2)): ((2, 2), (2, 2)),
                # wall rules
                ((0, 0), (1, 1)): ((0, 0), (1, 1)),
                ((0, 1), (1, 1)): ((0, 1), (1, 1)),
                ((0, 2), (1, 1)): ((2, 0), (1, 1)),
                ((2, 0), (1, 1)): ((0, 2), (1, 1)),
                ((2, 1), (1, 1)): ((2, 1), (1, 1)),
                ((2, 2), (1, 1)): ((2, 2), (1, 1)),
                ((1, 1), (1, 1)): ((1, 1), (1, 1)),
            }
            rules = {}
            # add rotations
            for r, v in base_rules.items():
                rules[r] = v
                for _ in range(3):
                    r = ((r[1][0], r[0][0]), (r[1][1], r[0][1]))
                    v = ((v[1][0], v[0][0]), (v[1][1], v[0][1]))
                    if r not in rules:
                        rules[r] = v
            return rules[n]

        ca = cpl.evolve2d_block(initial_conditions, block_size=(2, 2), timesteps=40, apply_rule=block2d_rule)

        np.testing.assert_equal(expected, ca.tolist())

    def test_sandpile(self):
        expected = self._convert_to_numpy_matrix("sandpile.ca")

        n_rows = 10
        n_cols = 10
        sandpile = cpl.Sandpile(n_rows, n_cols)

        np.random.seed(0)
        ca = np.random.randint(5, size=n_rows * n_cols).reshape((1, n_rows, n_cols))
        # we're using a closed boundary, so make the boundary cells 0
        ca[0, 0, :], ca[0, n_rows - 1, :], ca[0, :, 0], ca[0, :, n_cols - 1] = 0, 0, 0, 0

        ca = cpl.evolve2d(ca, timesteps=10, apply_rule=sandpile, neighbourhood="von Neumann")

        np.testing.assert_equal(expected, ca.tolist())

    def test_sandpile_memoized(self):
        expected = self._convert_to_numpy_matrix("sandpile.ca")

        n_rows = 10
        n_cols = 10
        sandpile = cpl.Sandpile(n_rows, n_cols)

        np.random.seed(0)
        ca = np.random.randint(5, size=n_rows * n_cols).reshape((1, n_rows, n_cols))
        # we're using a closed boundary, so make the boundary cells 0
        ca[0, 0, :], ca[0, n_rows - 1, :], ca[0, :, 0], ca[0, :, n_cols - 1] = 0, 0, 0, 0

        ca = cpl.evolve2d(ca, timesteps=10, apply_rule=sandpile, neighbourhood="von Neumann", memoize=True)

        np.testing.assert_equal(expected, ca.tolist())

    def test_sandpile_memoize_recursive(self):
        expected = self._convert_to_numpy_matrix("sandpile.ca")

        n_rows = 10
        n_cols = 10
        sandpile = cpl.Sandpile(n_rows, n_cols)

        np.random.seed(0)
        ca = np.random.randint(5, size=n_rows * n_cols).reshape((1, n_rows, n_cols))
        # we're using a closed boundary, so make the boundary cells 0
        ca[0, 0, :], ca[0, n_rows - 1, :], ca[0, :, 0], ca[0, :, n_cols - 1] = 0, 0, 0, 0

        ca = cpl.evolve2d(ca, timesteps=10, apply_rule=sandpile, neighbourhood="von Neumann", memoize="recursive")

        np.testing.assert_equal(expected, ca.tolist())

    def test_evolve_unknown_neighbourhood_type(self):
        cellular_automaton = np.array([ [[1,1,1], [1,1,1], [1,1,1]] ])
        with pytest.raises(Exception) as e:
            cpl.evolve2d(cellular_automaton, timesteps=2, neighbourhood='foo', apply_rule=cpl.game_of_life_rule)
        self.assertTrue("unknown neighbourhood type: foo" in str(e.value))

    def test_evolve_dynamic_timesteps(self):
        np.random.seed(0)

        n_rows = 10
        n_cols = 10
        sandpile = cpl.Sandpile(n_rows, n_cols)

        initial = np.random.randint(5, size=n_rows * n_cols).reshape((1, n_rows, n_cols))
        # we're using a closed boundary, so make the boundary cells 0
        initial[0, 0, :], initial[0, n_rows - 1, :], initial[0, :, 0], initial[0, :, n_cols - 1] = 0, 0, 0, 0

        ca = cpl.evolve2d(initial, timesteps=cpl.until_fixed_point(),
                          apply_rule=sandpile, neighbourhood="von Neumann")

        self.assertEqual(6, len(ca))

    def test_evolve_dynamic_timesteps_memoized(self):
        np.random.seed(0)

        n_rows = 10
        n_cols = 10
        sandpile = cpl.Sandpile(n_rows, n_cols)

        initial = np.random.randint(5, size=n_rows * n_cols).reshape((1, n_rows, n_cols))
        # we're using a closed boundary, so make the boundary cells 0
        initial[0, 0, :], initial[0, n_rows - 1, :], initial[0, :, 0], initial[0, :, n_cols - 1] = 0, 0, 0, 0

        ca = cpl.evolve2d(initial, timesteps=cpl.until_fixed_point(),
                          apply_rule=sandpile, neighbourhood="von Neumann", memoize=True)

        self.assertEqual(6, len(ca))

    def test_evolve_dynamic_timesteps_memoize_recursive(self):
        np.random.seed(0)

        n_rows = 10
        n_cols = 10
        sandpile = cpl.Sandpile(n_rows, n_cols)

        initial = np.random.randint(5, size=n_rows * n_cols).reshape((1, n_rows, n_cols))
        # we're using a closed boundary, so make the boundary cells 0
        initial[0, 0, :], initial[0, n_rows - 1, :], initial[0, :, 0], initial[0, :, n_cols - 1] = 0, 0, 0, 0

        ca = cpl.evolve2d(initial, timesteps=cpl.until_fixed_point(),
                          apply_rule=sandpile, neighbourhood="von Neumann", memoize="recursive")

        self.assertEqual(6, len(ca))

    def test_sandpile_add_grain(self):
        expected = self._convert_to_numpy_matrix("sandpile_add_grain.ca")

        n_rows = 10
        n_cols = 10
        sandpile = cpl.Sandpile(n_rows, n_cols)
        sandpile.add_grain(cell_index=(3, 3), timestep=1)

        initial = np.loadtxt(os.path.join(THIS_DIR, 'resources', 'sandpile_add_grain.txt'), dtype=int)
        initial = np.array([initial])

        ca = cpl.evolve2d(initial, timesteps=cpl.until_fixed_point(),
                          apply_rule=sandpile, neighbourhood="von Neumann")

        np.testing.assert_equal(expected, ca.tolist())

    def test_sandpile_prior_history(self):
        expected = self._convert_to_numpy_matrix("sandpile_prior_history.ca")

        n = 10
        sandpile = cpl.Sandpile(n, n)
        ca = cpl.init_simple2d(n, n, val=5)

        for i in range(3):
            ca[-1, n // 2, n // 2] += 1
            ca = cpl.evolve2d(ca, apply_rule=sandpile, timesteps=2, neighbourhood='Moore')

        np.testing.assert_equal(expected, ca.tolist())

    def test_plot2d(self):
        # this test ensures that the following code can run successfully without issue
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            cpl.plot2d([
                [[1, 0, 1], [1, 1, 1], [1, 1, 1]]
            ], title="some test")

    def test_plot2d_with_timestep(self):
        # this test ensures that the following code can run successfully without issue
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            cpl.plot2d([
                [[1, 0, 1], [1, 1, 1], [1, 1, 1]],
                [[1, 1, 1], [0, 1, 1], [1, 0, 1]]
            ], timestep=1, title="some test")

    def test_plot2d_slice(self):
        # this test ensures that the following code can run successfully without issue
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            cpl.plot2d_slice(np.array([
                [[1, 0, 1], [1, 1, 1], [1, 1, 1]]
            ]), title="some test")

    def test_plot2d_slice_with_slice(self):
        # this test ensures that the following code can run successfully without issue
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            cpl.plot2d_slice(np.array([
                [[1, 0, 1], [1, 1, 1], [1, 1, 1]],
                [[1, 1, 1], [0, 1, 1], [1, 0, 1]]
            ]), slice=1, title="some test")

    def test_plot2d_spacetime(self):
        # this test ensures that the following code can run successfully without issue
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            cpl.plot2d_spacetime(np.array([
                [[1, 0, 1], [1, 1, 1], [1, 1, 1]],
                [[1, 1, 1], [0, 1, 1], [1, 0, 1]],
                [[1, 1, 1], [0, 1, 1], [1, 0, 1]]
            ]), title="some test")

    def test_plot2d_animate(self):
        # this test ensures that the following code can run successfully without issue
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            cpl.plot2d_animate(np.array([
                [[1, 0, 1], [1, 1, 1], [1, 1, 1]],
                [[1, 1, 1], [0, 1, 1], [1, 0, 1]],
                [[1, 1, 1], [0, 1, 1], [1, 0, 1]]
            ]), title="some test")

    def _convert_to_numpy_matrix(self, filename):
        with open(os.path.join(THIS_DIR, 'resources', filename), 'r') as content_file:
            content = content_file.read()
            content = content.replace('{{{', '')
        content = content.replace('}}}', '')
        content = content.replace('{{', '')
        content = content.replace('{', '')
        content = [x.split('},') for x in content.split('}},')]
        content = [[h.split(',') for h in x] for x in content]
        content = [[[int(i) for i in h] for h in x] for x in content]
        return np.array(content, dtype=np.int32)

    def _create_ca(self, expected, rule, neighbourhood, memoize=False):
        steps, _, _ = expected.shape
        cellular_automaton = np.array([expected[0]])
        return cpl.evolve2d(cellular_automaton, timesteps=steps, r=1, neighbourhood=neighbourhood,
                            apply_rule=lambda n, c, t: cpl.totalistic_rule(n, k=2, rule=rule),
                            memoize=memoize)


 

========== FILE: tests/test_ctrbl_rule.py ==========

import unittest
import pytest
import cellpylib as cpl
import numpy as np


class TestCTRBLRule(unittest.TestCase):

    def test_rotations(self):
        ctrbl = cpl.CTRBLRule({
            (0, 1, 2, 3, 4): "a",
            (5, 6, 7, 8, 9): "b"
        })
        self.assertEqual(ctrbl.rule_table, {
            (0, 1, 2, 3, 4): "a",
            (5, 6, 7, 8, 9): "b"
        })

        ctrbl = cpl.CTRBLRule({
            (0, 1, 2, 3, 4): "a",
            (5, 6, 7, 8, 9): "b"
        }, add_rotations=True)
        self.assertEqual(ctrbl.rule_table, {
            (0, 1, 2, 3, 4): "a",
            (0, 4, 1, 2, 3): "a",
            (0, 3, 4, 1, 2): "a",
            (0, 2, 3, 4, 1): "a",
            (5, 6, 7, 8, 9): "b",
            (5, 9, 6, 7, 8): "b",
            (5, 8, 9, 6, 7): "b",
            (5, 7, 8, 9, 6): "b"
        })

    def test_rule(self):
        ctrbl_rule = cpl.CTRBLRule({
            (0, 1, 2, 3, 4): "a",
            (5, 6, 7, 8, 9): "b"
        })

        n = np.array([
            [0, 1, 0],
            [4, 0, 2],
            [0, 3, 0]
        ])
        activity = ctrbl_rule(n, 4, 1)
        self.assertEqual("a", activity)

    def test_activity_rule_does_not_exist(self):
        ctrbl_rule = cpl.CTRBLRule({
            (5, 6, 7, 8, 9): "b"
        })

        with pytest.raises(Exception) as e:
            n = np.array([
                [0, 1, 0],
                [4, 0, 2],
                [0, 3, 0]
            ])
            ctrbl_rule(n, 4, 1)
        self.assertEqual(e.value.args, ("neighbourhood state (0, 1, 2, 3, 4) not in rule table",))


 

========== FILE: tests/test_hopfield_net.py ==========

import unittest
import cellpylib as cpl
import numpy as np
import os

THIS_DIR = os.path.dirname(os.path.abspath(__file__))


class TestHopfieldNet(unittest.TestCase):

    def test_hopfield_net(self):
        np.random.seed(0)

        # patterns for training
        zero = [
            0, 1, 1, 1, 0,
            1, 0, 0, 0, 1,
            1, 0, 0, 0, 1,
            1, 0, 0, 0, 1,
            1, 0, 0, 0, 1,
            0, 1, 1, 1, 0,
            0, 0, 0, 0, 0]
        one = [
            0, 1, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 0, 0]
        two = [
            1, 1, 1, 0, 0,
            0, 0, 0, 1, 0,
            0, 0, 0, 1, 0,
            0, 1, 1, 0, 0,
            1, 0, 0, 0, 0,
            1, 1, 1, 1, 1,
            0, 0, 0, 0, 0]
        # replace the zeroes with -1 to make these vectors bipolar instead of binary
        one = [-1 if x == 0 else x for x in one]
        two = [-1 if x == 0 else x for x in two]
        zero = [-1 if x == 0 else x for x in zero]
        P = [zero, one, two]

        hopfield_net = cpl.HopfieldNet(num_cells=35)
        hopfield_net.train(P)

        expected_weights = self._convert_to_ndarray("hopfield_net_weights.txt")
        np.testing.assert_equal(expected_weights, hopfield_net.W)

        expected_activities = self._convert_to_ndarray("hopfield_net.ca")

        half_two = [
            0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
            0, 1, 1, 0, 0,
            1, 0, 0, 0, 0,
            1, 1, 1, 1, 1,
            0, 0, 0, 0, 0]
        half_two = [-1 if x == 0 else x for x in half_two]

        cellular_automaton = np.array([half_two])

        cellular_automaton = cpl.evolve(cellular_automaton, timesteps=155,
                                        apply_rule=hopfield_net.apply_rule, r=hopfield_net.r)

        np.testing.assert_equal(expected_activities, cellular_automaton)

    def _convert_to_ndarray(self, filename, dtype=int):
        with open(os.path.join(THIS_DIR, 'resources', filename), 'r') as content_file:
            content = content_file.read()
        content = content.replace('[[', '')
        content = content.replace(']]', '')
        content = content.replace('[', '')
        content = content.replace('],', ';')
        content = [[dtype(i) for i in x.split(',')] for x in content.split(';')]
        return np.array(content)

 

